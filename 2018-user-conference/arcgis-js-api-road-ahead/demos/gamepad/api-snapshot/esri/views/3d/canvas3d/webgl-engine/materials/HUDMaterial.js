// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.8/esri/copyright.txt for details.
//>>built
require({cache:{"url:esri/views/3d/canvas3d/webgl-engine/materials/HUDMaterial.xml":'\x3c?xml version\x3d"1.0" encoding\x3d"UTF-8"?\x3e\n\n\x3csnippets\x3e\n\n\x3csnippet name\x3d"HUDMaterialCommonVariables"\x3e\x3c![CDATA[\n\tuniform mat4 proj;\n\tuniform mat4 view;\n\tuniform mat4 model;\n\tuniform mat4 modelNormal;\n\tuniform vec4 viewport;\n\tuniform vec3 camPos;\n\tuniform float pixelRatio;\n\tuniform vec2 screenOffset;\n\tuniform vec2 anchorPos;\n\tuniform float polygonOffset;\n\n\tattribute vec3 $position;\n\tattribute vec3 $normal;\n\tattribute vec2 $uv0;\n\tattribute vec4 $color;\n    attribute vec2 $size;\n    attribute vec4 $auxpos1;\n\n\tvarying vec4 vcolor;\n\t\n#ifdef OCCL_PIXELSHADER\n \tvarying vec4 vtc;\n#else\n\tvarying vec2 vtc;\n\tuniform sampler2D framebufferTex;\n\tuniform vec3 markerColor;\n#endif\t\n\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"matchPixelOrigin"\x3e\x3c![CDATA[\n\tvec4 matchPixelOrigin(vec4 clipCoord, vec2 widthHeight) {\n\t\tvec2 xy \x3d vec2(.5) + .5 * clipCoord.xy / clipCoord.w;\n\t\tvec2 pixelSz \x3d vec2(1.0) / widthHeight;\n\t\tvec2 ij \x3d floor((xy + .5 * pixelSz) * widthHeight);\n\t\tvec2 result \x3d ((ij * pixelSz) * 2.0 - vec2(1.0)) * clipCoord.w;\n\t\treturn vec4(result.x, result.y, clipCoord.z, clipCoord.w);\n\t}\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"matchPixelCenter"\x3e\x3c![CDATA[\n\tvec4 matchPixelCenter(vec4 clipCoord, vec2 widthHeight) {\n\t\tvec2 xy \x3d vec2(.500123) + .5 * clipCoord.xy / clipCoord.w;\n\t\tvec2 ij \x3d floor(xy * widthHeight);\n\t\tvec2 pixelSz \x3d vec2(1.0) / widthHeight;\n\t\tvec2 result \x3d (((vec2(.5) + ij) * pixelSz) * 2.0 - vec2(1.0)) * clipCoord.w;\n\t\treturn vec4(result.x, result.y, clipCoord.z, clipCoord.w);\n\t}\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"calcPosMatchPixelCenter"\x3e\x3c![CDATA[\n\n\t\tvec3 posModel \x3d (model * vec4($position, 1.0)).xyz;\n\t\tvec3 posView \x3d (view * vec4(posModel, 1.0)).xyz;\n\n\t\tvec3 vnormal \x3d (modelNormal * vec4($normal, 1.0)).xyz;\n\n\t\t// view angle dependent part of polygon offset emulation\n\t\tfloat cosAlpha \x3d dot(vnormal, normalize(camPos - posModel));\n\t\tif (cosAlpha \x3e .01) {\n\t\t\tfloat tanAlpha \x3d sqrt(1.0 - cosAlpha * cosAlpha) / cosAlpha;\n\t\t\tposView *\x3d 1.0 - tanAlpha / viewport[2];\n\t\t}\n\n\t    if (centerOffset.w\x3c0.0)\n            posView+\x3dcenterOffset.xyz;\n\n\t\tvec4 posProj \x3d proj * vec4(posView, 1.0);\n\n\t\t// constant part of polygon offset emulation\n\t\tif (cosAlpha \x3e .01)\n\t\t\tposProj.z -\x3d polygonOffset * posProj.w;\n\n\t\tposProjCenter \x3d matchPixelCenter(posProj, viewport.zw);\n\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"vertexShaderHUD"\x3e\x3c![CDATA[\n    $HUDMaterialCommonVariables\n\n\t$matchPixelCenter\n\t$matchPixelOrigin\n\n\tvoid main(void) {\n\n\t    vec4 centerOffset \x3d $auxpos1;\n\n\t\tvec2 combinedSize \x3d $size * pixelRatio;\n\n        vec4 posProjCenter;\n\t\t$calcPosMatchPixelCenter\n\n#ifdef OCCL_TEST\n\t\tif (texture2D(framebufferTex, .5 + .5 * posProjCenter.xy / posProjCenter.w).rgb \x3d\x3d markerColor) {\n#endif\n\t\t\tvec2 uv01 \x3d floor($uv0);\n\t\t\tvec2 uv \x3d $uv0 - uv01;\n\t\t\tfloat dist \x3d distance(camPos, posModel);\n\t\t\tposProj.xy +\x3d ((uv01 - anchorPos) * 2.0 * combinedSize + screenOffset)/ viewport.zw * posProj.w;\n\t\t\tvtc.xy \x3d uv;\n#ifdef OCCL_TEST\n\t\t} else {\n\t\t\tvtc \x3d vec2(.0);\n\t\t}\n#endif\n\n#ifdef OCCL_PIXELSHADER\n\tvtc.zw \x3d .5 + .5 * posProjCenter.xy / posProjCenter.w;\n#endif\n\t\tgl_Position \x3d matchPixelOrigin(posProj, viewport.zw);\n\t\tvcolor \x3d $color / 255.0;\n\t}\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"vertexShaderHUDWorldScale"\x3e\x3c![CDATA[\n    $HUDMaterialCommonVariables\n\n\tuniform vec2 minMaxWorldSizeFactor;\n\n\t$matchPixelCenter\n\t$matchPixelOrigin\n\n\tvoid main(void) {\n\t    vec4 centerOffset \x3d $auxpos1;\n\t    vec2 combinedSize \x3d $size * pixelRatio;\n\t    \n\t    vec4 posProjCenter;\n\n\t\t$calcPosMatchPixelCenter\n\n#ifdef OCCL_TEST\n\t\tif (texture2D(framebufferTex, .5 + .5 * posProjCenter.xy / posProjCenter.w).rgb \x3d\x3d markerColor) {\n#endif\n\t\t\tfloat scale \x3d 1.0;\n\t\t\tvec2 minMaxWorldSize \x3d distance(camPos, position)*minMaxWorldSizeFactor;\n\t\t\tif (minMaxWorldSize.x \x3e combinedSize.y)\n\t\t\t\tscale \x3d minMaxWorldSize.x / combinedSize.y;\n\t\t\telse if (minMaxWorldSize.y \x3e 0.0)\n\t\t\t\tscale \x3d min(1.0, minMaxWorldSize.y / combinedSize.y);\n\n\t\t\tvec2 uv01 \x3d floor($uv0);\n\t\t\tvec2 uv \x3d $uv0 - uv01;\n\t\t\tposView.xy +\x3d (uv01 - anchorPos) * combinedSize * scale;\n\t\t\tuv.y +\x3d (1.0 - texScale.y);\n\t\t\tvtc.xy \x3d uv;\n#ifdef OCCL_TEST\n\t\t} else {\n\t\t\tvtc \x3d vec2(.0);\n\t\t}\n#endif\n\n#ifdef OCCL_PIXELSHADER\n\tvtc.zw \x3d .5 + .5 * posProjCenter.xy / posProjCenter.w;\n#endif\n\t\tposProj \x3d proj * vec4(posView,1.0);\n\t\tposProj.xy +\x3d screenOffset / viewport.zw * posProj.w;\n\t\tgl_Position \x3d posProj;\n\t\tvcolor \x3d $color;\n\t}\n]]\x3e\x3c/snippet\x3e\n\n\n\n\x3csnippet name\x3d"calcLabelDirections"\x3e\x3c![CDATA[\n\tvec2 uv01 \x3d floor($uv0);\n\tvec2 uv \x3d $uv0 - uv01;\n\n\tvec3 labelDir, labelDirOrtho;\n\n\tint isUp \x3d 0;\n\tvec2 vId \x3d (uv01 - vec2(.5, .5))*2.0;\n\n\tvec3 viewDirInNormalPlane \x3d normalize(camDir.xyz - dot(camDir.xyz, direction)*direction);\n\tfloat angleToNormal \x3d abs(dot(viewDirInNormalPlane,up));\n\tfloat angleToDirection \x3d abs(dot(camDir.xyz, direction));\n\tif (angleToDirection \x3c 0.985 \x26\x26 angleToNormal \x3c 0.500)\n\t{\n\t    if (angleToNormal \x3c 0.422) {\n\t\t    isUp \x3d 1;\n\t\t    labelDir \x3d direction;\n\t\t    labelDirOrtho \x3d up;\n\t\t    vId.y +\x3d 0.5;\n\t\t} else {\n\t\t    labelDir \x3d direction;\n            labelDirOrtho \x3d cross(viewDirInNormalPlane, direction);\n            vId.y +\x3d dot(labelDirOrtho, up)*0.5;\n\t\t}\n\t}\n\telse\n\t{\n\t\tlabelDir \x3d direction;\n\t\tlabelDirOrtho \x3d normalize(cross(up,direction));\n\t}\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"vertexShaderHUDDirection"\x3e\x3c![CDATA[\n \tuniform vec3 direction;\n \t\n\tvoid main(void) {\n\t    vec4 centerOffset \x3d $auxpos1;\n\t    vec2 combinedSize \x3d $size * pixelRatio;\n\n        vec4 posProjCenter;\n \t\t$calcPosMatchPixelCenter\n\n \t\tvec3 direction \x3d normalize(direction);\n \t\tvec3 up \x3d vnormal;\n \t\tvec3 camDir \x3d normalize(vec3(view[0][2],view[1][2],view[2][2]));\n\n #ifdef OCCL_TEST\n \t\tif (texture2D(framebufferTex, .5 + .5 * posProjCenter.xy / posProjCenter.w).rgb \x3d\x3d markerColor) {\n #endif\n\n \t\t\t$calcLabelDirections\n\n\t\t    float scale;\n\t\t    if (proj[2][3] !\x3d 0.0)  // perspective projection\n \t\t\t    scale \x3d posProj.w*0.5/viewport[2];\n \t\t\telse                    // othographic projection\n \t\t\t    scale \x3d 2.0/proj[0][0]/viewport[2];\n\n \t\t\tposModel.xyz +\x3d labelDir * vId.x * combinedSize.x * scale ;\n \t\t\tposModel.xyz +\x3d labelDirOrtho * vId.y * combinedSize.y * scale;\n\n \t\t\tvec4 posDirProj \x3d proj*view*model * vec4($position+direction, 1.0);\n \t\t\tvec4 posProjUnmodified \x3d proj*view*model * vec4($position, 1.0);\n \t\t\tif (posDirProj.x\x3cposProjUnmodified.x)\n \t\t\t{\n \t\t\t\tif (isUp\x3d\x3d1)\n \t\t\t\t\tuv.x \x3d texScale.x-uv.x;\n \t\t\t\telse\n \t\t\t\t\tuv \x3d texScale-uv;\n \t\t\t}\n \t\t\tvtc.xy \x3d uv;\n #ifdef OCCL_TEST\n \t\t} else {\n \t\t\tvtc \x3d vec2(.0);\n \t\t}\n #endif\n\n #ifdef OCCL_PIXELSHADER\n\tvtc.zw \x3d .5 + .5 * posProjCenter.xy / posProjCenter.w;\n#endif\n \t\tvec4 pos4 \x3d proj * view * vec4(posModel,1.0);\n \t\tgl_Position \x3d pos4;\n \t}\n ]]\x3e\x3c/snippet\x3e\n\n\n\x3csnippet name\x3d"vertexShaderHUDDirectionWorldScale"\x3e\x3c![CDATA[\n    $HUDMaterialCommonVariables\n    \n\tuniform vec2 minMaxWorldSizeFactor;\n\tuniform vec3 direction;\n\n\t$matchPixelCenter\n\t$matchPixelOrigin\n\n\tvoid main(void) {\n\t    vec4 centerOffset \x3d $auxpos1;\n\t    vec2 combinedSize \x3d $size * pixelRatio;\n\n        vec4 posProjCenter;\n\t\t$calcPosMatchPixelCenter\n\n\t\tvec3 direction \x3d normalize(direction);\n\t\tvec3 up \x3d vnormal;\n\t\tvec3 camDir \x3d normalize(vec3(view[0][2],view[1][2],view[2][2]));\n\n#ifdef OCCL_TEST\n\t\tif (texture2D(framebufferTex, .5 + .5 * posProjCenter.xy / posProjCenter.w).rgb \x3d\x3d markerColor) {\n#endif\n\n\t\t\t$calcLabelDirections\n\n\t\t\tfloat scale \x3d 1.0;\n\t\t\tvec2 minMaxWorldSize \x3d minMaxWorldSizeFactor;\n\t\t\tif (proj[2][3] !\x3d 0.0)  // perspective projection\n\t\t\t\tminMaxWorldSize \x3d distance(camPos, position)*minMaxWorldSizeFactor;\n\t\t\tif (minMaxWorldSize.x \x3e combinedSize.y)\n\t\t\t\tscale \x3d minMaxWorldSize.x / combinedSize.y;\n\t\t\telse if (minMaxWorldSize.y \x3e 0.0)\n\t\t\t\tscale \x3d min(1.0, minMaxWorldSize.y / combinedSize.y);\n\n\t\t\tposModel.xyz +\x3d labelDir*vId.x*combinedSize.x*scale;\n\t\t\tposModel.xyz +\x3d labelDirOrtho*vId.y*combinedSize.y*scale;\n\n\t\t\tvec4 posDirProj \x3d proj*view*model * vec4($position+direction, 1.0);\n\t\t\tvec4 posProjUnmodified \x3d proj*view*model * vec4($position, 1.0);\n \t\t\tif (posDirProj.x\x3cposProjUnmodified.x)\n \t\t\t{\n \t\t\t\tif (isUp\x3d\x3d1)\n \t\t\t\t\tuv.x \x3d texScale.x-uv.x;\n \t\t\t\telse\n \t\t\t\t\tuv \x3d texScale-uv;\n \t\t\t}\n \t\t\tuv.y +\x3d (1.0 - texScale.y);\n\t\t\tvtc.xy \x3d uv;\n#ifdef OCCL_TEST\n\t\t} else {\n\t\t\tvtc \x3d vec2(.0);\n\t\t}\n#endif\n\n#ifdef OCCL_PIXELSHADER\n\tvtc.zw \x3d .5 + .5 * posProjCenter.xy / posProjCenter.w;\n#endif\n\t\tvec4 pos4 \x3d proj * view * vec4(posModel,1.0);\n\t\tgl_Position \x3d pos4;\n\t}\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"fragmentShaderHUD"\x3e\x3c![CDATA[\n\tprecision mediump float;\n\n\tuniform sampler2D tex;\n\tuniform vec4 overrideColor;\n\n\n\tvarying vec4 vcolor;\n\n#ifdef OCCL_PIXELSHADER\n\tvarying vec4 vtc;\n\tuniform vec3 markerColor;\n\tuniform sampler2D framebufferTex;\n#else\n\tvarying vec2 vtc;\n#endif\n\n\tvoid main() {\n\n#ifdef OCCL_PIXELSHADER\n   \t\tif (texture2D(framebufferTex, vtc.zw).rgb !\x3d markerColor)\n   \t\t\tdiscard;\n#endif\n\n\t\tgl_FragColor \x3d texture2D(tex, vtc, -0.5) * overrideColor * vcolor;\n\t\tif (gl_FragColor.a \x3c .1) discard;\n\t}\n]]\x3e\x3c/snippet\x3e\n\n\n\x3csnippet name\x3d"vertexShaderOcclusionTestPixel"\x3e\x3c![CDATA[\n\tuniform mat4 proj;\n\tuniform mat4 view;\n\tuniform mat4 model;\n\tuniform mat4 modelNormal;\n\tuniform vec4 viewport;\n\tuniform vec3 camPos;\n\tuniform float polygonOffset;\n\n\tattribute vec3 $position;\n\tattribute vec3 $normal;\n\tattribute vec4 $auxpos1;\n\n\t$matchPixelCenter\n\n\tvoid main(void) {\n\t    vec4 centerOffset \x3d $auxpos1;\n\n\t    vec4 posProjCenter;\n\t    if (dot($position, $position) \x3e 0.0) {\n\t\t    $calcPosMatchPixelCenter\n\t\t} else {\n\t\t    posProjCenter \x3d vec4(1e038, 1e038, 1e038, 1.0);\n\t\t}\n\n\t\tgl_Position \x3d posProjCenter;\n\t\tgl_PointSize \x3d 1.0;\n\t}\n]]\x3e\x3c/snippet\x3e\n\n\x3c/snippets\x3e'}});
define("dojo/_base/lang dojo/text!./HUDMaterial.xml ./internal/MaterialUtil ../lib/GLSLProgram ../lib/GLSLShader ../lib/ShaderVariations ../lib/VertexBufferLayout ../lib/Util ../lib/gl-matrix".split(" "),function(H,I,v,J,F,K,L,G,B){var M=B.vec2d,x=B.vec3d,N=B.mat4d,A=G.assert,g=G.VertexAttrConstants,y=window.WebGLRenderingContext,C={bottomLeft:[0,0],bottom:[.5,0],bottomRight:[1,0],left:[0,.5],center:[.5,.5],right:[1,.5],topLeft:[0,1],top:[.5,1],topRight:[1,1]},z=function(c,D){v.basicMaterialConstructor(this,
D);c=c||null;c.texCoordScale=c.texCoordScale||[1,1];c.occlusionTest=void 0!==c.occlusionTest?c.occlusionTest:!0;c.color=c.color||[1,1,1,1];c.screenMinMaxSize=c.screenMinMaxSize||[0,1E5];c.screenOffset?c.screenOffset.forEach(function(r,a){c.screenOffset[a]=2*r}):c.screenOffset=[0,0];"string"===typeof c.anchorPos?(A(C[c.anchorPos],"HUDMaterial: invalid anchorPos specified"),c.anchorPos=C[c.anchorPos]):c.anchorPos||(c.anchorPos=C.center);c.shaderPolygonOffset=c.shaderPolygonOffset||1E-5;var E=new L([g.POSITION,
g.NORMAL,g.UV0,g.COLOR,g.SIZE,g.AUXPOS1],[3,3,2,4,2,4],[y.FLOAT,y.FLOAT,y.FLOAT,y.UNSIGNED_BYTE,y.FLOAT,y.FLOAT]),d=E.getStride(),f=4*d;this.dispose=function(){};this.getParameterValues=function(){var a={color:c.color,texCoordScale:c.texCoordScale,polygonOffset:c.polygonOffset,anchorPos:c.anchorPos,screenOffset:c.screenOffset,screenMinMaxSize:c.screenMinMaxSize,shaderPolygonOffset:c.shaderPolygonOffset};c.textureId&&(a.textureId=c.textureId);c.direction&&(a.direction=c.direction);return a};this.setParameterValues=
function(a){for(var r in a)"textureId"===r&&A(c.textureId,"Can only change texture of material that already has a texture"),"direction"===r&&A(c.direction,"Can only change direction of HUDMaterial which was initialized with a direction"),c[r]=a[r];this.notifyDirty("matChanged")};this.getParams=function(){return c};this.getOutputAmount=function(a){return a*d*6};this.getVertexBufferLayout=function(){return E};this.fillInterleaved=function(a,k,q,l,e,n){l=v.fill;for(var r=E.getAttributes(),p=a.faces.indices[g.POSITION],
t=a.vertexAttr[g.POSITION].data,b=n+r[g.POSITION].offset,m=0;m<p.length;++m){var h=3*p[m];l(t,h,e,b,k,3);b+=d;l(t,h,e,b,k,3);b+=d;l(t,h,e,b,k,3);b+=d;l(t,h,e,b,k,3);b+=d;l(t,h,e,b,k,3);b+=d;l(t,h,e,b,k,3);b+=d}k=a.faces.indices[g.NORMAL];t=a.vertexAttr[g.NORMAL].data;b=n+r[g.NORMAL].offset;for(m=0;m<k.length;++m)h=3*k[m],l(t,h,e,b,q,3),b+=d,l(t,h,e,b,q,3),b+=d,l(t,h,e,b,q,3),b+=d,l(t,h,e,b,q,3),b+=d,l(t,h,e,b,q,3),b+=d,l(t,h,e,b,q,3),b+=d;b=n+r[g.UV0].offset;m=a.vertexAttr[g.UV0].data;null==m||3>=
m.length?(q=h=0,k=c.texCoordScale[0],t=c.texCoordScale[1]):(h=a.vertexAttr[g.UV0].data[0],q=a.vertexAttr[g.UV0].data[1],k=a.vertexAttr[g.UV0].data[2],t=a.vertexAttr[g.UV0].data[3]);k=Math.min(1.99999,k+1);t=Math.min(1.99999,t+1);for(m=0;m<p.length;++m)e[b]=h,e[b+1]=q,b+=d,e[b]=k,e[b+1]=q,b+=d,e[b]=k,e[b+1]=t,b+=d,e[b]=k,e[b+1]=t,b+=d,e[b]=h,e[b+1]=t,b+=d,e[b]=h,e[b+1]=q,b+=d;p=a.faces.indices[g.COLOR];q=a.vertexAttr[g.COLOR].data;b=4*(n+r[g.COLOR].offset);k=new Uint8Array(e.buffer);for(m=0;m<p.length;++m)h=
4*p[m],l(q,h,k,b,null,4),b+=f,l(q,h,k,b,null,4),b+=f,l(q,h,k,b,null,4),b+=f,l(q,h,k,b,null,4),b+=f,l(q,h,k,b,null,4),b+=f,l(q,h,k,b,null,4),b+=f;p=a.faces.indices[g.SIZE];h=a.vertexAttr[g.SIZE].data;b=n+r[g.SIZE].offset;for(m=0;m<p.length;++m)q=h[2*p[m]],k=h[2*p[m]+1],e[b]=q,e[b+1]=k,b+=d,e[b]=q,e[b+1]=k,b+=d,e[b]=q,e[b+1]=k,b+=d,e[b]=q,e[b+1]=k,b+=d,e[b]=q,e[b+1]=k,b+=d,e[b]=q,e[b+1]=k,b+=d;if(null!=a.faces.indices[g.AUXPOS1]&&null!=a.vertexAttr[g.AUXPOS1])for(p=a.faces.indices[g.AUXPOS1],a=a.vertexAttr[g.AUXPOS1].data,
b=n+r.auxpos1.offset,m=0;m<a.length;++m)h=4*p[m],l(a,h,e,b,null,4),b+=d,l(a,h,e,b,null,4),b+=d,l(a,h,e,b,null,4),b+=d,l(a,h,e,b,null,4),b+=d,l(a,h,e,b,null,4),b+=d,l(a,h,e,b,null,4),b+=d};var u=x.create(),n=x.create(),w=[0,0],a=c.anchorPos;this.intersect=function(c,d,f,l,e,D,v,p,t,b,m){if(m)for(d=c.getData().getVertexAttr()[g.POSITION],c=c.getData().getVertexAttr()[g.SIZE],A(3<=d.size),v=0;v<d.data.length/d.size;v++)if(p=v*d.size,x.set3(d.data[p],d.data[p+1],d.data[p+2],u),N.multiplyVec3(f,u,u),p=
v*c.size,w[0]=c.data[p],w[1]=c.data[p+1],t.projectPoint(u,n),-1<n[0]){p=n[0]-1-(0<a[0]?w[0]*a[0]:0);m=p+w[0];var h=n[1]-1-(0<a[1]?w[1]*a[1]:0),k=h+w[1];l[0]>p&&l[0]<m&&l[1]>h&&l[1]<k&&(p=x.subtract(e,u,x.create()),m=x.length(p),x.scale(p,1/m),m=.98*m/x.dist(e,D),b(m,p,-1,1,!0))}};this.getGLMaterials=function(){return[O,void 0,void 0]};this.getAllTextureIds=function(){return[c.textureId]};this._textureDirty=!1;this.setTextureDirty=function(){this._textureDirty=!0}},O=function(c,g,x){v.basicGLMaterialConstructor(this,
c);var d=0,f=H.clone(c.getParams()),u=g.get("hudOcclusionTestPixel"),n=z.programs.getProgram([!!f.direction,!!f.worldScale,f.occlusionTest]);v.singleTextureGLMaterialConstructor(this,x,f);var w=[254/255,253/255,252/255];this.beginSlot=function(a){d=a;return f.occlusionTest?2===a||3==a:2===a};this.getProgram=function(){return 2===d&&f.occlusionTest?u:n};this.getAllPrograms=function(){return[u,n]};this.updateParameters=function(){var a=c.getParams();f.color=a.color;f.texCoordScale=a.texCoordScale;f.polygonOffset=
a.polygonOffset;f.anchorPos=a.anchorPos;f.screenOffset=a.screenOffset;f.screenMinMaxSize=a.screenMinMaxSize;f.direction=a.direction;f.shaderPolygonOffset=a.shaderPolygonOffset;this.updateTexture(a.textureId)};this.bind=function(a,r){c._textureDirty&&(this.renderTexture(a),c._textureDirty=!1);if(2===d&&f.occlusionTest)u.use(),u.uniform1f("polygonOffset",f.shaderPolygonOffset),u.uniform4fv("viewport",r.viewport),u.uniform4f("color",w[0],w[1],w[2],1),c.getVertexBufferLayout().enableVertexAttribArrays(a,
u),a.depthFunc(a.LEQUAL);else{n.use();this.bindTexture(a,n);n.uniform1i("framebufferTex",1);a.activeTexture(a.TEXTURE1);a.bindTexture(a.TEXTURE_2D,r.framebufferTex);a.activeTexture(a.TEXTURE0);n.uniform3fv("markerColor",w);n.uniform4fv("viewport",r.viewport);n.uniform4fv("overrideColor",f.color);n.uniform1f("pixelRatio",r.pixelRatio);n.uniform1f("polygonOffset",f.shaderPolygonOffset);if(f.worldScale){var k=[-1,-1],g=f.screenMinMaxSize,l=r.proj;r=r.viewport[2]/r.pixelRatio;g&&(0!==l[11]?(l=Math.tan(2*
Math.atan(1/l[0])/2)/r*2,k[0]=g[0]*l,k[1]=g[1]*l):M.scale(g,2/(l[0]*r),k));n.uniform2fv("minMaxWorldSizeFactor",k)}f.direction&&n.uniform3fv("direction",f.direction);n.uniform2fv("texScale",f.texCoordScale);n.uniform2fv("screenOffset",f.screenOffset);n.uniform2fv("anchorPos",f.anchorPos);c.getVertexBufferLayout().enableVertexAttribArrays(a,n);f.polygonOffset&&(a.enable(a.POLYGON_OFFSET_FILL),a.polygonOffset(0,-4));a.web3DDefaultState.cullFace&&a.disable(a.CULL_FACE);a.enable(a.BLEND)}};this.release=
function(a){2===d&&f.occlusionTest?(a.depthFunc(a.LESS),c.getVertexBufferLayout().disableVertexAttribArrays(a,u)):(f.polygonOffset&&a.disable(a.POLYGON_OFFSET_FILL),a.web3DDefaultState.cullFace&&a.enable(a.CULL_FACE),a.disable(a.BLEND),c.getVertexBufferLayout().disableVertexAttribArrays(a,n))};this.bindView=function(a,c){a=c.origin;2===d&&f.occlusionTest?(v.bindView(a,c.view,u),v.bindCamPos(a,c.viewInvTransp,u)):(v.bindView(a,c.view,n),v.bindCamPos(a,c.viewInvTransp,n))};this.bindInstance=function(a,
c){2===d&&f.occlusionTest?(u.uniformMatrix4fv("model",c.transformation),u.uniformMatrix4fv("modelNormal",c.transformationNormal)):n.uniformMatrix4fv("model",c.transformation)};this.getDrawMode=function(a){return 2===d&&f.occlusionTest?a.POINTS:a.TRIANGLES}};z.programs=null;z.loadShaders=function(c,g,v,d){c._parse(I);var f=0<d.getParameter(d.MAX_VERTEX_TEXTURE_IMAGE_UNITS);g=new K("hud",["vertexShaderHUD","fragmentShaderHUD"],null,v,null,c,d);g.addBinaryShaderSnippetSuffix("Direction","Direction",
[!0,!1]);g.addBinaryShaderSnippetSuffix("WorldScale","WorldScale",[!0,!1]);g.addDefine("OcclTest",f?"OCCL_TEST":"OCCL_PIXELSHADER");f=new F(d.VERTEX_SHADER,c.vertexShaderOcclusionTestPixel,d);c=new F(d.FRAGMENT_SHADER,c.fragmentShaderSimple,d);d=new J([f,c],d);v.add("hudOcclusionTestPixel",d);z.programs=g};return z});