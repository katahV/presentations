// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.8/esri/copyright.txt for details.
//>>built
require({cache:{"url:esri/views/3d/interactive/measurementTools/directLineMeasurement3D/LaserLine.xml":'\x3c?xml version\x3d"1.0" encoding\x3d"UTF-8"?\x3e\n\n\x3csnippets\x3e\n\n\x3csnippet name\x3d"fsLaserLine"\x3e\x3c![CDATA[\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n\n  $fsprecisionf\n\n  varying vec2 uv;\n\n  uniform sampler2D depthMap;\n\n  uniform vec2 nearFar;\n  uniform vec4 projInfo;\n  uniform vec2 zScale;\n  uniform float maxPixelDistance;\n\n  // focus plane in camera space\n  uniform vec4 focusPlane;\n\n  // focus sphere in camera space\n  uniform vec4 focusSphere;\n\n  // segment plane in camera space\n  uniform vec4 segmentPlane;\n\n  // line segment\n  uniform vec3 segmentStart;\n  uniform vec3 segmentEnd;\n\n  // styling\n  uniform vec3 glowColor;\n  uniform float glowWidth;\n  uniform vec3 innerColor;\n  uniform float innerWidth;\n  uniform float globalAlpha;\n\n  #define INFINITY 100000.0\n\n  $rgba2float\n\n  // reconstruct depth value from linear depth map\n  float linearDepth(vec2 uv) {\n    return -(rgba2float(texture2D(depthMap, uv)) * (nearFar[1] - nearFar[0]) + nearFar[0]);\n  }\n\n  // reconstruct position in view space\n  vec3 reconstructPosition(vec2 fragCoord, float depth) {\n    return vec3((fragCoord * projInfo.xy + projInfo.zw) * (zScale.x * depth + zScale.y), depth);\n  }\n\n#ifdef GL_OES_standard_derivatives\n  float planeDistancePixels(vec4 plane, vec3 pos) {\n    // compute distance to plane\n    float dist \x3d dot(plane.xyz, pos) + plane.w;\n    // compute derivative of distance function with respect to pixels\n    float width \x3d fwidth(dist);\n    // normalize distance by the derivative to get a measurement with respect to pixels\n    // the clamping is used to prevent excessive artifacts along depth discontinuities\n    dist /\x3d min(width, maxPixelDistance);\n    return abs(dist);\n  }\n\n  float sphereDistancePixels(vec4 sphere, vec3 pos) {\n    // compute distance to sphere\n    float dist \x3d distance(sphere.xyz, pos) - sphere.w;\n    // compute derivative of distance function with respect to pixels\n    float width \x3d fwidth(dist);\n    // normalize distance by the derivative to get a measurement with respect to pixels\n    // the clamping is used to prevent excessive artifacts along depth discontinuities\n    dist /\x3d min(width, maxPixelDistance);\n    return abs(dist);\n  }\n#endif\n\n  vec4 blendPremultiplied(vec4 source, vec4 dest) {\n    float oneMinusSourceAlpha \x3d 1.0 - source.a;\n\n    return vec4(\n      source.rgb + dest.rgb * oneMinusSourceAlpha,\n      source.a + dest.a * oneMinusSourceAlpha\n    );\n  }\n\n  vec4 premultipliedColor(vec3 rgb, float alpha) {\n    return vec4(rgb * alpha, alpha);\n  }\n\n  // computes laser line color based on distance in pixels\n  vec4 laserLineProfile(float dist) {\n    if (dist \x3e glowWidth) {\n      return vec4(0.0);\n    }\n\n    float innerAlpha \x3d (1.0 - smoothstep(0.0, innerWidth, dist));\n    float glowAlpha \x3d pow(max(0.0, 1.0 - dist / glowWidth), 8.0);\n\n    return blendPremultiplied(\n      premultipliedColor(innerColor, innerAlpha),\n      premultipliedColor(glowColor, glowAlpha)\n    );\n  }\n\n  void main() {\n#ifdef GL_OES_standard_derivatives\n    // do not draw laserline on background\n    float depth \x3d linearDepth(uv);\n    if (-depth \x3d\x3d nearFar[0]) {\n      discard;\n    }\n\n    // reconstruct position in view space\n    vec3 pos \x3d reconstructPosition(gl_FragCoord.xy, depth);\n\n    // empirical hack to fade out laser line in problematic areas:\n    // the derivatives to normalize the distance function are valid inside smooth surfaces,\n    // but break down at depth discontinuities (e.g. edges). We fade out the laser lines in\n    // areas where depth valus have large variations in order to avoid this problem.\n    float ddepth \x3d fwidth(depth);\n    float depthDiscontinuityAlpha \x3d 1.0 - smoothstep(0.0, 0.01, -ddepth / depth);\n\n    // reconstruct normal using derivatives\n    vec3 normal \x3d normalize(cross(dFdx(pos), dFdy(pos)));\n\n    // distance to focus plane\n    float focusPlaneDistance \x3d planeDistancePixels(focusPlane, pos);\n\n    // distance to focus sphere\n    float focusSphereDistance \x3d sphereDistancePixels(focusSphere, pos);\n\n    // distance to segment plane\n    float segmentDistance \x3d INFINITY;\n    float segmentLength \x3d length(segmentEnd - segmentStart);\n    vec3 segmentDir \x3d (segmentEnd - segmentStart) / segmentLength;\n    float t \x3d dot(segmentDir, pos - segmentStart);\n\n    if (segmentLength \x3e 0.0 \x26\x26 t \x3e\x3d 0.0 \x26\x26 t \x3c\x3d segmentLength) {\n      segmentDistance \x3d planeDistancePixels(segmentPlane, pos);\n    }\n\n    // evaluate color profile for both planes and the sphere\n    vec4 focusPlaneColor \x3d laserLineProfile(focusPlaneDistance);\n    vec4 focusSphereColor \x3d laserLineProfile(focusSphereDistance);\n    vec4 segmentColor \x3d laserLineProfile(segmentDistance);\n\n    // empirical hack to fade out laser line when planes are nearly parallel\n    float focusPlaneAlpha \x3d 1.0 - smoothstep(0.995, 0.999, abs(dot(normal, focusPlane.xyz)));\n    float focusSphereAlpha \x3d 1.0 - smoothstep(0.995, 0.999, abs(dot(normal, normalize(pos - focusSphere.xyz))));\n    float segmentAlpha \x3d 1.0 - smoothstep(0.995, 0.999, abs(dot(normal, segmentPlane.xyz)));\n\n    // combine colors\n    vec4 color \x3d max(\n      focusPlaneColor * focusPlaneAlpha,\n      max(\n        focusSphereColor * focusSphereAlpha,\n        segmentColor * segmentAlpha\n      )\n    );\n\n    gl_FragColor \x3d color * globalAlpha * depthDiscontinuityAlpha;\n#else\n    // we might compute the derivatives ourselves, but because\n    // GL_OES_standard_derivatives should be widely supported we just\n    // disable laser lines when support is missing.\n    gl_FragColor \x3d vec4(0.0);\n#endif\n  }\n]]\x3e\x3c/snippet\x3e\n\n\x3c/snippets\x3e\n'}});
define("require exports ../../../../../core/tsSupport/extendsHelper dojo/text!./LaserLine.xml ../../../lib/glMatrix ../../../webgl-engine/lib/DefaultVertexAttributeLocations ../../../webgl-engine/lib/glUtil3D ../../../webgl-engine/lib/RenderSlot ../../../webgl-engine/lib/Util ../../../webgl-engine/materials/internal/MaterialUtil ../../../../webgl/Program".split(" "),function(B,C,D,t,a,u,v,w,x,p,y){function q(c,f,e,g){var r=l,b=z;a.mat4d.multiplyVec3(g,f,r);a.vec3d.set(e,b);b[3]=0;a.mat4d.multiplyVec4(g,
b);a.vec4d.set4(b[0],b[1],b[2],-a.vec3d.dot(b,r),c)}var l=a.vec3d.create(),z=a.vec4d.create(),A={glowColor:[1,.5,0],glowWidth:8,innerColor:[1,1,1],innerWidth:1,globalAlpha:.75};return function(){function c(f,e){void 0===e&&(e={});this._projInfo=a.vec4d.create();this._zScale=a.vec2d.create();this._segmentActive=this._focusSphereActive=this._focusPlaneActive=!1;this._focusPosition=a.vec3d.create();this._focusSpherePosition=a.vec3d.create();this._segmentStartPosition=a.vec3d.create();this._segmentEndPosition=
a.vec3d.create();this._needsRender=!1;this._tempNormal=a.vec3d.create();this._tempDir=a.vec3d.create();this._tempUp=a.vec3d.create();this._tempVec3=a.vec3d.create();this._tempVec4=a.vec4d.create();this.didRender=!1;this._renderCoordsHelper=f;this._params=p.copyParameters(e,A)}Object.defineProperty(c.prototype,"needsRender",{get:function(){return this._needsRender},enumerable:!0,configurable:!0});Object.defineProperty(c.prototype,"renderSlots",{get:function(){return[w.POSTPROCESSING_EXTERNAL]},enumerable:!0,
configurable:!0});Object.defineProperty(c.prototype,"needsLinearDepth",{get:function(){return!0},enumerable:!0,configurable:!0});Object.defineProperty(c.prototype,"focusPlaneActive",{get:function(){return this._focusPlaneActive},set:function(a){a!==this._focusPlaneActive&&(this._focusPlaneActive=a,this._needsRender=!0)},enumerable:!0,configurable:!0});Object.defineProperty(c.prototype,"focusSphereActive",{get:function(){return this._focusSphereActive},set:function(a){a!==this._focusSphereActive&&
(this._focusSphereActive=a,this._needsRender=!0)},enumerable:!0,configurable:!0});Object.defineProperty(c.prototype,"segmentActive",{get:function(){return this._segmentActive},set:function(a){a!==this._segmentActive&&(this._segmentActive=a,this._needsRender=!0)},enumerable:!0,configurable:!0});Object.defineProperty(c.prototype,"focusPosition",{get:function(){return this._focusPosition},set:function(f){a.vec3d.set(f,this._focusPosition);this._needsRender=!0},enumerable:!0,configurable:!0});Object.defineProperty(c.prototype,
"focusSpherePosition",{get:function(){return this._focusSpherePosition},set:function(f){a.vec3d.set(f,this._focusSpherePosition);this._needsRender=!0},enumerable:!0,configurable:!0});Object.defineProperty(c.prototype,"segmentStartPosition",{get:function(){return this._segmentStartPosition},set:function(f){a.vec3d.set(f,this._segmentStartPosition);this._needsRender=!0},enumerable:!0,configurable:!0});Object.defineProperty(c.prototype,"segmentEndPosition",{get:function(){return this._segmentEndPosition},
set:function(f){a.vec3d.set(f,this._segmentEndPosition);this._needsRender=!0},enumerable:!0,configurable:!0});c.prototype.setParameterValues=function(a){p.updateParameters(this._params,a)&&(this._needsRender=!0)};c.prototype.initializeRenderContext=function(a){var e=a.rctx;this._quadVAO=v.createQuadVAO(e);a.shaderSnippets.fsLaserLine||a.shaderSnippets._parse(t);this._laserLineProgram=new y(e,a.shaderSnippets.vsUVQuad,a.shaderSnippets.fsLaserLine,u.Default3D)};c.prototype.uninitializeRenderContext=
function(a){this._quadVAO.dispose();this._quadVAO=null;this._laserLineProgram.dispose();this._projInfo=this._laserLineProgram=null};c.prototype.resetNeedsRender=function(){this.didRender&&(this._needsRender=this.didRender=!1)};c.prototype.render=function(c){var e=c.rctx,g=c.camera,f=this._renderCoordsHelper,b=this._laserLineProgram,d=this._projInfo,h=this._zScale;e.bindProgram(b);x.inverseProjectionInfo(g.projectionMatrix,g.fullWidth,g.fullHeight,d,h);b.setUniform4fv("projInfo",d);b.setUniform2fv("zScale",
h);b.setUniform2f("nearFar",g.near,g.far);b.setUniform1f("maxPixelDistance",2*g.computePixelSizeAt(this._focusPosition));if(this._focusPlaneActive){var d=this._focusPosition,h=this._tempVec3,k=this._tempVec4;f.worldUpAtPosition(d,h);q(k,d,h,g.viewMatrix);b.setUniform4fv("focusPlane",k)}else b.setUniform4fv("focusPlane",[0,0,0,1E10]);this._focusSphereActive?(h=this._tempVec4,d=this._tempVec3,a.vec3d.set(this._focusSpherePosition,h),a.mat4d.multiplyVec3(g.viewMatrix,h),a.vec3d.set(this._focusPosition,
d),a.mat4d.multiplyVec3(g.viewMatrix,d),h[3]=a.vec3d.dist(h,d),b.setUniform4fv("focusSphere",h)):b.setUniform4fv("focusSphere",[0,0,0,1E10]);if(this._segmentActive){var d=this._tempVec4,h=this._tempVec3,k=this._tempUp,m=this._tempDir,n=this._tempNormal;a.vec3d.lerp(this._segmentStartPosition,this._segmentEndPosition,.5,h);f.worldUpAtPosition(h,k);a.vec3d.subtract(this._segmentEndPosition,this._segmentStartPosition,m);a.vec3d.normalize(m);a.vec3d.cross(k,m,n);a.vec3d.normalize(n);q(d,this._segmentStartPosition,
n,g.viewMatrix);b.setUniform4fv("segmentPlane",d)}else b.setUniform4fv("segmentPlane",[0,0,0,1E10]);d=l;a.vec3d.set(this._segmentStartPosition,d);f.setAltitude(0,d);a.mat4d.multiplyVec3(g.viewMatrix,d);b.setUniform3fv("segmentStart",d);d=l;a.vec3d.set(this._segmentEndPosition,d);f.setAltitude(0,d);a.mat4d.multiplyVec3(g.viewMatrix,d);b.setUniform3fv("segmentEnd",d);b.setUniform1i("depthMap",0);e.bindTexture(c.depth.colorTexture,0);b.setUniform3fv("innerColor",this._params.innerColor);b.setUniform1f("innerWidth",
this._params.innerWidth);b.setUniform3fv("glowColor",this._params.glowColor);b.setUniform1f("glowWidth",this._params.glowWidth);b.setUniform1f("globalAlpha",this._params.globalAlpha);e.bindVAO(this._quadVAO);e.setDepthTestEnabled(!1);e.setDepthWriteEnabled(!1);e.setBlendFunctionSeparate(1,771,770,771);e.setBlendingEnabled(!0);e.drawArrays(5,0,4);e.setDepthTestEnabled(!0);e.setDepthWriteEnabled(!0);e.setBlendingEnabled(!1);return!0};return c}()});