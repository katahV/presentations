// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.8/esri/copyright.txt for details.
//>>built
require({cache:{"url:esri/views/3d/webgl-engine/materials/internal/ssao.xml":'\x3c?xml version\x3d"1.0" encoding\x3d"UTF-8"?\x3e\n\n\x3csnippets\x3e\n\n\t\x3csnippet name\x3d"createFsSSAOSrc"\x3e\x3c![CDATA[\n\n\t$fsprecisionf\n\n\tuniform sampler2D rnm;\n\tuniform sampler2D normalMap;\n\tuniform sampler2D depthMap;\n\tuniform float\t\tssaoAtt;\n\tuniform vec2\t\trnmScale;\n\tuniform float\t\tradius;\n\tuniform vec2\t\tnearFar;\n\tuniform vec3\t\tpSphere[64];\n\n\tvarying vec2\t\tuv;\n\n\tconst\tfloat\t\tstrength \x3d .07;\n\tconst\tfloat\t\tfalloff \x3d .000002;\n\n\t$rgba2float\n\tvoid main(void) {\n\t\tvec3 fres \x3d normalize((texture2D(rnm, uv * rnmScale).xyz * 2.0) - vec3(1.0));\n\t\tfloat currentPixelDepth \x3d rgba2float(texture2D(depthMap, uv));\n\t\tvec3 ep \x3d vec3(uv.xy, currentPixelDepth);\n\t\tvec3 norm \x3d vec3(-1.0) + 2.0 * texture2D(normalMap, uv).xyz;\n\t\tfloat bl \x3d .0;\n\t\tfloat f \x3d mix(nearFar.x, nearFar.y, currentPixelDepth) / nearFar.x;\n\t\tfloat radD \x3d radius / f;\n\t\tradD \x3d min(radD, .5);\n\t\tfloat depthDifference;\n\t\tvec3 ray;\n\n\t\tfor(int i \x3d 0; i \x3c NUM_TAP_SAMPLES; ++i) {\n\t\t\tray \x3d radD*reflect(pSphere[i], fres);\n\t\t\tvec2 tc \x3d ep.xy + sign(dot(ray, norm) ) * ray.xy;\n\t\t\tif (tc.x \x3e\x3d .0 \x26\x26 tc.y \x3e\x3d .0 \x26\x26 tc.x \x3c\x3d 1.0 \x26\x26 tc.y \x3c\x3d 1.0) {\n\t\t\t\tfloat occluderDepth \x3d rgba2float(texture2D(depthMap, tc));\n\t\t\t\tvec3 occluderNormal \x3d vec3(-1.0) + 2.0 * texture2D(normalMap, tc).xyz;\n\t\t\t\tdepthDifference \x3d currentPixelDepth - occluderDepth;\n\t\t\t\tbl +\x3d step(falloff, depthDifference) * (1.0 - dot(occluderNormal, norm)) * (1.0 - smoothstep(falloff, strength, depthDifference));\n\t\t\t};\n\t\t}\n\n\t\tfloat ao \x3d 1.0 + bl * (-1.38 / float(NUM_TAP_SAMPLES)) * ssaoAtt;\n\t\tgl_FragColor.a \x3d ao;\n\t}\n]]\x3e\x3c/snippet\x3e\n\n\t\x3csnippet name\x3d"getDepthLinear"\x3e\x3c![CDATA[\n\tfloat getDepthLinear(vec2 ssC) {\n\t\treturn -(rgba2float(texture2D(depthMap, ssC))*(nearFar[1] - nearFar[0])+nearFar[0]);\n\t}\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"createFsSSAOSrcObscurance"\x3e\x3c![CDATA[\n\t$fsprecisionf\n\n\tuniform mat4 projMatrixInv;\n\n\tuniform sampler2D normalMap;\n\tuniform sampler2D depthMap;\n\n\tuniform float     intensity;\n\n\tuniform float projScale;\n\tuniform float     radius;\n\tuniform vec2      nearFar;\n\n\tuniform vec4      projInfo;\n\n\tuniform vec2\t  screenDimensions;\n\n\t//noise texture lookup could be replaced with hash function if WebGL gets XOR functionality\n\tuniform vec3\t\tpSphere[NUM_TAP_SAMPLES]; //tap position\n\tuniform vec2\t\trnmScale;\n\tuniform sampler2D rnm; //noise texture\n\n\t//set z scaling, used to prevent division in ortho mode\n\tuniform vec2 zScale;\n\n\tvarying vec2  uv;\n\tvarying vec4  camPos;\n\n\t$rgba2float\n\t$getDepthLinear\n\n\t/** Returns a unit vector and a screen-space radius for the tap on a unit disk (the caller should scale by the actual disk radius) */\n\t/*uniform float numSpiralTurns;\n\tvec2 tapLocation(int sampleNumber, float spinAngle, out float ssR){\n\t\t// Radius relative to ssR\n\t\tfloat alpha \x3d (float(sampleNumber) + 0.5) * (1.0 / float(NUM_TAP_SAMPLES));\n\t\tfloat angle \x3d alpha * (numSpiralTurns * 6.28) + spinAngle;\n\n\t\tssR \x3d alpha;\n\t\treturn vec2(cos(angle), sin(angle));\n\t}*/\n\n\n\tfloat fallOffFunction(float vv, float vn, float bias) {\n\t  float radius2 \x3d radius * radius;\n\n\t\t// A: From the HPG12 paper\n\t\t// Note large epsilon to avoid overdarkening within cracks\n\t\t// return float(vv \x3c radius2) * max((vn - bias) / (epsilon + vv), 0.0) * radius2 * 0.6;\n\n\t\t// B: Smoother transition to zero (lowers contrast, smoothing out corners). [Recommended]\n\t\tfloat f \x3d max(radius2 - vv, 0.0); return f * f * f * max(vn-bias, 0.0);\n\n\t\t// C: Medium contrast (which looks better at high radii), no division.  Note that the\n\t\t// contribution still falls off with radius^2, but we\'ve adjusted the rate in a way that is\n\t\t// more computationally efficient and happens to be aesthetically pleasing.\n\t\t// return 4.0 * max(1.0 - vv * invRadius2, 0.0) * max(vn - bias, 0.0);\n\n\t\t// D: Low contrast, no division operation\n\t\t// return 2.0 * float(vv \x3c radius * radius) * max(vn - bias, 0.0);\n\t}\n\n\n\t/** Compute the occlusion due to sample point \\a Q about camera-space point \\a C with unit normal \\a n_C */\n\tfloat aoValueFromPositionsAndNormal(vec3 C, vec3 n_C, vec3 Q) {\n\t\tvec3 v \x3d Q - C;\n\t\tfloat vv \x3d dot(v, v);\n\t\tfloat vn \x3d dot(normalize(v), n_C);\n\t\treturn fallOffFunction(vv, vn, 0.1);\n\t}\n\n\n\t/** Reconstruct camera-space P.xyz from screen-space S \x3d (x, y) in\n\t\tpixels and camera-space z \x3c 0.  Assumes that the upper-left pixel center\n\t\tis at (0.5, 0.5) [but that need not be the location at which the sample tap\n\t\twas placed!]\n\n\t\tCosts 3 MADD.  Error is on the order of 10^3 at the far plane, partly due to z precision.\n\t  */\n\tvec3 reconstructCSPosition(vec2 S, float z) {\n\t\treturn vec3(( (S.xy) * projInfo.xy + projInfo.zw)*(z*zScale.x+zScale.y), z);\n\t}\n\n\tvoid main(void)\n\t{\n\n\t\t//Hash function used in the HPG12 AlchemyAO paper\n\t\t//Not supported in WebGL -\x3e using texture lookup as in old SSAO shader instead\n\t\t//ivec2 ssC \x3d ivec2(gl_FragCoord.xy);\n\t\t//float randomPatternRotationAngle \x3d float((3 * ssC.x ^ ssC.y + ssC.x * ssC.y) * 10);\n\t\tvec3 fres \x3d normalize((texture2D(rnm, uv * rnmScale).xyz * 2.0) - vec3(1.0));\n\n\t   float currentPixelDepth \x3d getDepthLinear(uv);\n\n\t   if (-currentPixelDepth\x3enearFar.y || -currentPixelDepth\x3cnearFar.x) {\n\t\tgl_FragColor \x3d vec4(0);\n\t\treturn;\n\t   }\n\n\t   vec3 currentPixelPos \x3d reconstructCSPosition(gl_FragCoord.xy,currentPixelDepth);\n\n\t   // get the normal of current fragment\n\t   vec4 norm4 \x3d texture2D(normalMap, uv);\n\t   vec3 norm \x3d vec3(-1.0) + 2.0 * norm4.xyz;\n\t   bool isTerrain \x3d norm4.w\x3c0.5;\n\n\t   float sum \x3d .0;\n\n\t   vec4 occluderFragment;\n\t   vec3 ray;\n\n\t   vec3 tapPixelPos;\n\n\t   // note: the factor 2.0 should not be necessary, but makes ssao much nicer.\n\t   // bug or deviation from CE somewhere else?\n\t   float ps \x3d projScale/(2.0*currentPixelPos.z*zScale.x+zScale.y);\n\n\t   for(int i \x3d 0; i \x3c NUM_TAP_SAMPLES; ++i)\n\t   {\n\t\t  // get a vector (randomized inside of a sphere with radius 1.0) from a texture and reflect it\n\t\t  //float ssR;\n\t\t  //vec2 unitOffset \x3d tapLocation(i, randomPatternRotationAngle, ssR);\n\t\t  // get the depth of the occluder fragment\n\t\t  //vec2 offset \x3d vec2(-unitOffset*radius*ssR*ps);\n\n\t\t  vec2 unitOffset \x3d reflect(pSphere[i], fres).xy;\n\t\t  vec2 offset \x3d vec2(-unitOffset*radius*ps);\n\n\n\t\t  //don\'t use current or very nearby samples\n\t\t  if ( abs(offset.x)\x3c2.0 || abs(offset.y)\x3c2.0) continue;\n\n\n\t\t  vec2 tc \x3d vec2(gl_FragCoord.xy + offset);\n\t\t  if (tc.x \x3c 0.0 || tc.y \x3c 0.0 || tc.x \x3e screenDimensions.x || tc.y \x3e screenDimensions.y) continue;\n\t\t  vec2 tcTap \x3d tc/screenDimensions;\n\t\t  float occluderFragmentDepth \x3d getDepthLinear(tcTap);\n\n\t\t  if (isTerrain) {\n\t\t  \tbool isTerrainTap \x3d texture2D(normalMap, tcTap).w\x3c0.5;\n\t\t  \tif (isTerrainTap)\n\t\t  \t\tcontinue;\n\t\t  }\n\n\t\t  tapPixelPos \x3d reconstructCSPosition(tc, occluderFragmentDepth);\n\n\t\t  sum+\x3d aoValueFromPositionsAndNormal(currentPixelPos, norm, tapPixelPos);\n\t   }\n\n\t   // output the result\n\n\t\tfloat A \x3d max(1.0-sum*intensity/float(NUM_TAP_SAMPLES),0.0);\n\n\t\t// Anti-tone map to reduce contrast and drag dark region farther\n\t\t// (x^0.2 + 1.2 * x^4)/2.2\n\t\tA \x3d (pow(A, 0.2) + 1.2 * A*A*A*A) / 2.2;\n\n\n\t   //gl_FragColor \x3d vec4(norm/2.0+0.5, 1.0);\n\t   //gl_FragColor \x3d vec4(-currentPixelDepth/1000.0);\n\t   //gl_FragColor \x3d vec4(tapPixelPos.x/100.0);\n\t   gl_FragColor \x3d vec4(A);\n\n\n\t}\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"fsBlurEdgeAware"\x3e\x3c![CDATA[\n\t$fsprecisionf\n\n\tuniform sampler2D normalMap;\n\tuniform sampler2D depthMap;\n\tuniform sampler2D tex;\n\n\n\tuniform vec2 blurSize;\n\n\n\tuniform float g_BlurFalloff;\n\tuniform float projScale;\n\n\n\tvarying vec2 uv;\n\n\tuniform vec2\t\tnearFar;\n\n\t//set z scaling, used to prevent division in ortho mode\n\tuniform vec2 zScale;\n\n\t$rgba2float\n\t$getDepthLinear\n\n\tfloat BlurFunction(vec2 uv, float r, float center_d, inout float w_total, float sharpness)\n\t{\n\t\tfloat c \x3d texture2D(tex, uv).r;\n\t\tfloat d \x3d getDepthLinear(uv);\n\n\t\tfloat ddiff \x3d d - center_d;\n\n\t\tfloat w \x3d exp(-r*r*g_BlurFalloff - ddiff*ddiff*sharpness);\n\n\t\tw_total +\x3d w;\n\n\t\treturn w*c;\n\t}\n\n\tvoid main(void)\n\t{\n\n\t\tfloat b \x3d 0.0;\n\t\tfloat w_total \x3d 0.0;\n\n\t\tfloat center_d \x3d  getDepthLinear(uv);\n\n\t\tfloat sharpness \x3d -0.05*projScale/(center_d*zScale.x+zScale.y);\n\t\tfor (int r \x3d -RADIUS; r \x3c\x3d RADIUS; ++r)\n\t\t{\n\t\t\tfloat rf \x3d float(r);\n\t\t\tvec2 uvOffset \x3d uv + rf*blurSize;\n\t\t\tb +\x3d BlurFunction(uvOffset, rf, center_d, w_total, sharpness);\n\t\t}\n\n\t\tgl_FragColor \x3d vec4(b/w_total);\n\t}\n]]\x3e\x3c/snippet\x3e\n\n\n\t\x3csnippet name\x3d"fsBlurSrc0"\x3e\x3c![CDATA[\n\t$fsprecisionf\n\n\tuniform sampler2D tex;\n\tuniform float blurSize;\n\tvarying vec2 uv;\n\n\tvoid main() {\n\t\tint rad \x3d RADIUS - 1;\n\n\t\tvec4 sum \x3d vec4(0.0);\n\t\tfor (int k \x3d -RADIUS; k \x3c\x3d RADIUS; ++k) { \t\t// NOTE for-variable-init must be a const expression\n\t\t\tfloat fi \x3d float(k);\n]]\x3e\x3c/snippet\x3e\n\n\t\x3csnippet name\x3d"fsBlurSrc1"\x3e\x3c![CDATA[\n\t\t}\n\n\t\tgl_FragColor \x3d sum / float(RADIUS * RADIUS);\n\t}\n]]\x3e\x3c/snippet\x3e\n\n\t\x3csnippet name\x3d"fsBlurH"\x3e\x3c![CDATA[\n\t$fsBlurSrc0\n\t\t\tsum +\x3d texture2D(tex, vec2(uv.x + fi * blurSize, uv.y)) * (float(rad) - abs(fi) + 1.0);\n\t$fsBlurSrc1\n]]\x3e\x3c/snippet\x3e\n\n\t\x3csnippet name\x3d"fsBlurV"\x3e\x3c![CDATA[\n\t$fsBlurSrc0\n\t\t\tsum +\x3d texture2D(tex, vec2(uv.x, uv.y + fi * blurSize)) * (float(rad) - abs(fi) + 1.0);\n\t$fsBlurSrc1\n]]\x3e\x3c/snippet\x3e\n\n\x3c/snippets\x3e\n'}});
define("require exports dojo/text!../materials/internal/ssao.xml ../../../../core/Logger ../../support/imageUtils ./DefaultVertexAttributeLocations ./DefaultVertexBufferLayouts ./gl-matrix ./glUtil3D ./Util ../../../webgl/BufferObject ../../../webgl/FramebufferObject ../../../webgl/Program ../../../webgl/Texture ../../../webgl/Util ../../../webgl/VertexArrayObject".split(" "),function(w,u,x,y,z,g,A,p,v,q,B,t,l,C,r,D){var E=y.getLogger("esri.views.3d.webgl-engine.lib.SSAOHelper");u=function(){function e(a,
c,b,e){this._enabled=!1;this._BLUR_F=2;this._attenuation=.5;this._radius=3;this._samples=16;this._viewportToRestore=p.vec4d.create();this._rctx=b;this._programRep=a;this._requestRender=e;this._emptyTexture=v.createEmptyTexture(b)}e.prototype.dispose=function(){this._emptyTexture.dispose();this._emptyTexture=null};Object.defineProperty(e.prototype,"isSupported",{get:function(){var a=this._rctx,c=-1!==a.parameters.versionString.indexOf("WebGL 0.93"),b=-1!==a.parameters.versionString.indexOf("WebGL 0.94");
return a.capabilities.standardDerivatives&&!(c||b)},enumerable:!0,configurable:!0});Object.defineProperty(e.prototype,"enabled",{get:function(){return this._enabled},set:function(a){a?this.enable():this.disable()},enumerable:!0,configurable:!0});Object.defineProperty(e.prototype,"attenuation",{get:function(){return this._attenuation},set:function(a){this._attenuation=a},enumerable:!0,configurable:!0});Object.defineProperty(e.prototype,"radius",{get:function(){return this._radius},set:function(a){this._radius=
a},enumerable:!0,configurable:!0});Object.defineProperty(e.prototype,"filterRadius",{get:function(){return 4},enumerable:!0,configurable:!0});Object.defineProperty(e.prototype,"samples",{get:function(){return this._samples},set:function(a){this._samples=a},enumerable:!0,configurable:!0});e.prototype.computeSSAO=function(a,c,b,e){if(this._noiseTexture){q.assert(this.enabled);var d=this._rctx,f=b.width,h=b.height,n=f/this._BLUR_F,g=h/this._BLUR_F;this._ssaoFBO.resize(f,h);this._blur0FBO.resize(n,g);
this._blur1FBO.resize(n,g);n=1*f;g=1*h;d.bindFramebuffer(this._ssaoFBO);p.vec4d.set(a.fullViewport,this._viewportToRestore);d.setViewport(0,0,f,h);var k=this._programRep.get(8>=this._samples?"ssao8":16>=this._samples?"ssao16":32>=this._samples?"ssao32":"ssao64"),m=this._programRep.get("blur");k.setUniform2f("rnmScale",f/this._noiseTexture.descriptor.width,h/this._noiseTexture.descriptor.height);k.setUniform3fv("pSphere",8>=this._samples?this._data.random8:16>=this._samples?this._data.random16:32>=
this._samples?this._data.random32:this._data.random64);d.bindProgram(k);f=this._data.minDiscrepancy;k.setUniform1f("numSpiralTurns",this._samples<f.length?f[this._samples]:5779);f=F;h=G;q.inverseProjectionInfo(a.projectionMatrix,a.fullWidth,a.fullHeight,f,h);k.setUniform4fv("projInfo",f);k.setUniform2fv("zScale",h);k.setUniform2f("nearFar",a.near,a.far);f=1/a.computePixelSizeAtDist(1);k.setUniform1f("projScale",1*f);k.setUniform2f("screenDimensions",n,g);var l=2*this._radius,h=p.vec3d.dist(a.eye,
a.center),l=20*a.computePixelSizeAtDist(h),l=Math.max(.1,l);k.setUniform1f("radius",l);k.setUniform1f("intensity",4*this._attenuation/Math.pow(l,6));k.setUniform1i("rnm",0);k.setUniform1i("normalMap",1);k.setUniform1i("depthMap",2);d.bindTexture(this._noiseTexture,0);d.bindTexture(e.colorTexture,1);d.bindTexture(b.colorTexture,2);b=v.createQuadVAO(this._rctx);d.bindVAO(b);d.drawArrays(5,0,r.vertexCount(b,"geometry"));d.bindTexture(this._ssaoFBO.colorTexture,0);d.setViewport(0,0,n/this._BLUR_F,g/this._BLUR_F);
d.bindFramebuffer(this._blur0FBO);m.setUniform2f("screenDimensions",n,g);m.setUniform1i("tex",0);m.setUniform1i("normalMap",1);m.setUniform1i("depthMap",2);m.setUniform2f("blurSize",0,1*this._BLUR_F/g);m.setUniform1i("radius",4);m.setUniform1f("g_BlurFalloff",.08);m.setUniform2f("nearFar",a.near,a.far);5E4<h&&(f=Math.max(0,f-(h-5E4)));m.setUniform1f("projScale",f);m.setUniform2f("zScale",1,0);d.drawArrays(5,0,r.vertexCount(b,"geometry"));m.setUniform2f("blurSize",1*this._BLUR_F/n,0);d.bindFramebuffer(this._blur1FBO);
d.bindTexture(this._blur0FBO.colorTexture,0);d.drawArrays(5,0,r.vertexCount(b,"geometry"));d.bindFramebuffer(c);d.setViewport(this._viewportToRestore[0],this._viewportToRestore[1],this._viewportToRestore[2],this._viewportToRestore[3])}};e.prototype.setUniforms=function(a){var c=this.enabled&&this._noiseTexture,b=this._rctx;b.bindTexture(c?this._blur1FBO.colorTexture:this._emptyTexture,6);b.setActiveTexture(0);a.setUniform1i("ssaoTex",6);c?a.setUniform4f("viewportPixelSz",this._viewportToRestore[0],
this._viewportToRestore[1],1/this._ssaoFBO.width,1/this._ssaoFBO.height):a.setUniform4f("viewportPixelSz",-1,-1,-1,-1)};e.prototype.bindAll=function(a){a=a.getProgramsUsingUniform("viewportPixelSz");for(var c=0;c<a.length;c++)this.setUniforms(a[c])};e.prototype.drawQuad=function(a){q.assert(this.enabled);var c=this._programRep.get("showDepth");this._debugQuadVAO||(this._debugQuadVAO=new D(this._rctx,g.Default3D,{geometry:A.Pos2Tex},{geometry:B.createVertex(this._rctx,35044,H)}));var b=this._rctx;
b.setDepthTestEnabled(!1);c.setUniformMatrix4fv("proj",new Float32Array(a));c.setUniform1i("depthTex",0);b.bindTexture(this._ssaoFBO.colorTexture,0);b.bindVAO(this._debugQuadVAO);b.drawArrays(5,0,r.vertexCount(this._debugQuadVAO,"geometry"));b.setDepthTestEnabled(!0)};e.prototype.enable=function(){var a=this;this.enabled||(this.isSupported?(this._enabled=!0,this.loadResources(function(){a._enabled&&a.initialize()})):E.warn("SSAO is not supported for this browser or hardware"))};e.prototype.loadResources=
function(a){var c=this;this._data?a():w(["./SSAOHelperData"],function(b){c._data=b;a()})};e.prototype.initialize=function(){var a=this,c={target:3553,pixelFormat:6408,dataType:5121,samplingMode:9729,wrapMode:33071,width:0,height:0},b={colorTarget:0,depthStencilTarget:0};this._ssaoFBO=t.createWithAttachments(this._rctx,c,b);this._blur0FBO=t.createWithAttachments(this._rctx,c,b);this._blur1FBO=t.createWithAttachments(this._rctx,c,b);z.requestImage(this._data.noiseTexture).then(function(b){a._enabled&&
(a._noiseTexture=new C(a._rctx,{target:3553,pixelFormat:6408,dataType:5121,hasMipmap:!0,width:b.width,height:b.height},b),a._requestRender())})};e.prototype.disable=function(){this.enabled&&(this._enabled=!1,this._quadVAO&&(this._quadVAO.dispose(!0),this._quadVAO=null),this._noiseTexture&&(this._noiseTexture.dispose(),this._noiseTexture=null),this._blur1FBO&&(this._blur1FBO.dispose(),this._blur1FBO=null),this._blur0FBO&&(this._blur0FBO.dispose(),this._blur0FBO=null),this._ssaoFBO&&(this._ssaoFBO.dispose(),
this._ssaoFBO=null))};e.loadShaders=function(a,c,b){q.assert(null==a.samples);a._parse(x);var e=new l(b,a.vertexShaderShowDepth,a.fragmentShaderShowDepth,g.Default3D),d=a.createFsSSAOSrcObscurance,f=new l(b,a.vsUVQuad,d,g.Default3D,{NUM_TAP_SAMPLES:"8"}),h=new l(b,a.vsUVQuad,d,g.Default3D,{NUM_TAP_SAMPLES:"16"}),n=new l(b,a.vsUVQuad,d,g.Default3D,{NUM_TAP_SAMPLES:"32"}),d=new l(b,a.vsUVQuad,d,g.Default3D,{NUM_TAP_SAMPLES:"64"});a=new l(b,a.vsUVQuad,a.fsBlurEdgeAware,g.Default3D,{RADIUS:(4).toString()});
c.add("showDepth",e);c.add("ssao8",f);c.add("ssao16",h);c.add("ssao32",n);c.add("ssao64",d);c.add("blur",a)};return e}();var G=p.vec2d.create(),F=p.vec4d.create(),H=new Float32Array([0,0,0,0,512,0,1,0,0,512,0,1,512,512,1,1]);return u});