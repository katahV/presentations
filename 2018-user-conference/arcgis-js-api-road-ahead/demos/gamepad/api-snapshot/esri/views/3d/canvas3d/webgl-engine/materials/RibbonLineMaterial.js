// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.8/esri/copyright.txt for details.
//>>built
require({cache:{"url:esri/views/3d/canvas3d/webgl-engine/materials/RibbonLineMaterial.xml":'\x3c?xml version\x3d"1.0" encoding\x3d"UTF-8"?\x3e\r\n\r\n\x3csnippets\x3e\r\n\r\n\x3csnippet name\x3d"vsRibbonLine"\x3e\x3c![CDATA[\r\n\tuniform mat4 proj;\r\n\tuniform mat4 view;\r\n\tuniform mat4 model;\r\n\r\n\tuniform float extLineWidth;\r\n\tuniform float nearPlane;\r\n\r\n\tattribute vec3 $position;\t\r\n\tattribute vec2 $uv0;\r\n\tvarying vec2 vtc;\r\n\r\n\tattribute vec4 $color;\r\n\tvarying vec4 vColor;\r\n\r\n\tattribute float size;\r\n\r\n#ifndef WALL\r\n\tuniform float miterLimit;\r\n\tattribute vec3 $auxpos1;\r\n\tattribute vec3 $auxpos2;\r\n#endif\r\n\r\n#ifdef SCREENSCALE\r\n\tuniform vec2 screenSize;\r\n\t$toScreenCoords\r\n#define VECTYPE vec2\r\n#define ZEROVEC vec2(0.0, 0.0)\r\n#define PERPENDICULAR(v) vec2(v.y, -v.x);\r\n#define ISOUTSIDE (left.x * right.y - left.y * right.x)*$uv0.y \x3e 0.0\r\n\r\n#else //ifdef SCREENSCALE\r\n\r\n#define VECTYPE vec3\r\n#define ZEROVEC vec3(0.0, 0.0, 0.0)\r\n// these macros are only valid for "strip" type lines:\r\n#define PERPENDICULAR(v) cross(up/*vec3(0.0, 1.0, 0.0)*/, v)\r\n#define ISOUTSIDE dot(cross(left, right), up/*vec3(0.0, 1.0, 0.0)*/)*$uv0.y \x3c 0.0\r\n\r\n#endif //ifdef SCREENSCALE\r\n\r\n\tfloat interp(float ncp, vec4 a, vec4 b) {\r\n\t\treturn (-ncp - a.z) / (b.z - a.z);\r\n\t}\r\n\r\n#ifdef SCREENSCALE\r\n\r\n  void clipAndTransform(inout vec4 pos, inout vec4 prev, inout vec4 next) {\r\n\t\tfloat vnp \x3d nearPlane*0.99;\r\n\r\n\t\t//We have four vertices per point on the line. Start and end vertices \r\n\t\t//are treated differently --\x3e d \x3e 0, d \x3c 0\r\n\t\tfloat d \x3d abs($uv0.y) - 1.1;\r\n\r\n\t\t//current pos behind ncp --\x3e we need to clip\r\n\t\tif(pos.z \x3e -nearPlane) {\t\t\t\r\n\t\t\tif (d \x3c 0.0) {\r\n\t\t\t\t//previous in front of ncp\r\n\t\t\t\tif(prev.z \x3c -nearPlane) {\r\n\t\t\t\t\tpos \x3d mix(prev, pos, interp(vnp, prev, pos));\r\n\t\t\t\t\tnext \x3d pos;\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\t  pos \x3d vec4(0, 0, 0, 1);\r\n\t\t\t  }\r\n\t\t\t}\r\n\t\t\t//next in front of ncp\r\n\t\t\tif(d \x3e 0.0) {\r\n\t\t\t\tif(next.z \x3c -nearPlane) {\r\n\t\t\t\t\tpos \x3d mix(pos, next, interp(vnp, pos, next));\r\n\t\t\t\t\tprev \x3d pos;\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\tpos \x3d vec4(0, 0, 0, 1);\r\n\t\t\t\t}\r\n\t\t\t}\t\t\t\r\n\t\t}\telse { \r\n\t\t\t//current position visible \r\n\t\t\t//previous behind ncp\r\n\t\t\tif (prev.z \x3e -nearPlane) {\t\t\t\t\r\n\t\t\t\tprev \x3d mix(pos, prev, interp(vnp, pos, prev));\t\t\t\t\r\n\t\t\t}\t\t\t\t\t\r\n\t\t\t//next behind ncp\r\n\t\t\tif (next.z \x3e -nearPlane) {\r\n\t\t\t\tnext \x3d mix(next, pos, interp(vnp, next, pos));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tpos\x3d proj * pos;\r\n\t\tpos.xy *\x3d screenSize;\r\n\t\tpos /\x3d pos.w;\r\n\r\n\t\tnext \x3d proj * next;\r\n\t\tnext.xy *\x3d screenSize;\r\n\t\tnext /\x3d next.w;\r\n\r\n\t\tprev \x3d proj * prev;\r\n\t\tprev.xy *\x3d screenSize;\r\n\t\tprev /\x3d prev.w;\t\t\r\n  }\r\n\r\n#endif // SCREENSCALE\r\n\r\n\tvoid main(void) {\r\n\r\n\tfloat lineWidth \x3d extLineWidth + $size; \r\n\r\n#ifdef SCREENSCALE\r\n\r\n#if 0\r\n\t\tvec4 pos \x3d toScreenCoords($position.xyz);\r\n\t\tvec2 left \x3d (pos - toScreenCoords($auxpos1)).xy;\r\n\t\tvec2 right \x3d (toScreenCoords($auxpos2) - pos).xy;\r\n#else\r\n\t\tvec4 pos  \x3d view * vec4((model * vec4($position.xyz, 1.0)).xyz, 1.0); \r\n\t\tvec4 prev \x3d view * vec4((model * vec4($auxpos1.xyz, 1.0)).xyz, 1.0); \r\n\t\tvec4 next \x3d view * vec4((model * vec4($auxpos2.xyz, 1.0)).xyz, 1.0); \r\n\r\n\t\tclipAndTransform(pos, prev, next);\r\n\r\n\t\tvec2 left \x3d (pos - prev).xy;\r\n\t\tvec2 right \x3d (next - pos).xy;\r\n#endif\r\n\r\n#else // ifdef SCREENSCALE\r\n\t\tvec4 pos \x3d vec4($position, 1.0);\r\n#ifndef WALL\r\n\t\tvec3 left \x3d $position.xyz - $auxpos1;\r\n\t\tvec3 right \x3d $auxpos2 - $position.xyz;\r\n\t\tvec3 up \x3d normalize($position.xyz);\r\n#endif // ifndef WALL\r\n#endif // ifdef SCREENSCALE\r\n\r\n#ifdef WALL\r\n\t\tfloat displacementLen \x3d lineWidth;\r\n\t\tvec3 displacementDir \x3d normalize($position.xyz);//vec3(0.0, 1.0, 0.0);\r\n#else // ifdef WALL\r\n\r\n\t\tfloat leftLen \x3d length(left);\r\n\t\tleft \x3d (leftLen \x3e 0.001) ? left/leftLen : ZEROVEC;\r\n\r\n\t\tfloat rightLen \x3d length(right);\r\n\t\tright \x3d (rightLen \x3e 0.001) ? right/rightLen : ZEROVEC;\r\n\r\n\t\t// determine if vertex is on the "outside or "inside" of the join\r\n\t\tbool isOutside \x3d ISOUTSIDE;\r\n\r\n\t\t// compute miter join position first\r\n\t\tfloat displacementLen \x3d lineWidth;\r\n\t\tVECTYPE displacementDir \x3d normalize(left + right);\r\n\t\tdisplacementDir \x3d PERPENDICULAR(displacementDir);\r\n\t\tif (leftLen \x3e 0.001 \x26\x26 rightLen \x3e 0.001) {\r\n\t\t\tfloat nDotSeg \x3d dot(displacementDir, left);\r\n\t\t\tdisplacementLen /\x3d length(nDotSeg*left - displacementDir);\r\n\r\n\t\t\t// limit displacement of inner vertices\r\n\t\t\tif (!isOutside)\r\n\t\t\t\tdisplacementLen \x3d min(displacementLen, min(leftLen, rightLen)/abs(nDotSeg));\r\n\t\t}\r\n\r\n\t\tif (isOutside \x26\x26 (displacementLen \x3e miterLimit*lineWidth)) {\r\n\t\t\t// convert to bevel join if miterLimit is exceeded\r\n\t\t\tif (leftLen \x3c 0.001)\r\n\t\t\t    displacementDir \x3d right;\r\n\t\t\telse if (rightLen \x3c 0.001)\r\n\t\t\t\tdisplacementDir \x3d left;\r\n\t\t\telse\r\n\t\t\t\tdisplacementDir \x3d (abs($uv0.y) - 1.1 \x3c 0.0) ? left : right;\r\n\t\t\tdisplacementDir \x3d normalize(displacementDir);\r\n\t\t\tdisplacementDir \x3d PERPENDICULAR(displacementDir);\r\n\t\t\tdisplacementLen \x3d lineWidth;\r\n\t\t}\r\n\r\n#endif // ifdef WALL\r\n\r\n#ifdef SCREENSCALE\r\n\t\tpos.xy +\x3d displacementDir * floor($uv0.y + 0.5) * displacementLen;\r\n\t\tpos.xy /\x3d screenSize;\r\n#else\r\n\t\tpos.xyz +\x3d displacementDir * floor($uv0.y + 0.5) * displacementLen;\r\n\t\tpos \x3d proj * view * model * pos;\r\n#endif\r\n\r\n\t\tvtc \x3d $uv0;\r\n\t\tvColor \x3d $color * 0.003921568627451; // \x3d 1/255\r\n\t\tgl_Position \x3d pos;\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fsRibbonLine"\x3e\x3c![CDATA[\r\n\tprecision mediump float;\r\n\r\n\tuniform vec4 eColor;\r\n\tvarying vec4 vColor;\r\n\tvarying vec2 vtc;\r\n\r\n\tvoid main() {\r\n\t\tgl_FragColor \x3d eColor * vColor;\r\n\t\t//gl_FragColor.a \x3d 1;\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3c/snippets\x3e'}});
define("dojo/_base/lang dojo/text!./RibbonLineMaterial.xml ./internal/MaterialUtil ../lib/VertexBufferLayout ../lib/GLSLProgram ../lib/GLSLShader ../lib/Util ../lib/gl-matrix".split(" "),function(M,N,G,J,H,E,F,B){var O=[255,255,255,255],P=[0,0,0,0],h=B.vec3d,K=B.vec2d,L=B.mat4d,t=h.create(),y=h.create(),A=h.create(),I=h.create(),C=K.create(),D=K.create();B=function(f,q){G.basicMaterialConstructor(this,q);q=window.WebGLRenderingContext;var g=F.VertexAttrConstants;f=f||{};f.color=f.color||[1,1,1,1];
f.width=f.width||0;f.type=f.type||"screen";f.join=f.join||"miter";f.miterLimit="miter"===f.join?f.miterLimit||5:f.miterLimit;var e="wall"===f.type?2:4,d="wall"===f.type?new J([g.POSITION,g.UV0],[3,2]):new J([g.POSITION,g.UV0,g.AUXPOS1,g.AUXPOS2,g.COLOR,g.SIZE],[3,2,3,3,4,1],[q.FLOAT,q.FLOAT,q.FLOAT,q.FLOAT,q.FLOAT,q.FLOAT]);this.canBeMerged=!1;this.getParams=function(){return f};this.getParameterValues=function(){var k={color:f.color,width:f.width,type:f.type,join:f.join,polygonOffset:f.polygonOffset};
"miter"===f.join&&(k.miterLimit=f.miterLimit);return k};this.setParameterValues=function(k){for(var c in k)k.hasOwnProperty(c)&&(F.assert("type"!==c,"RibbonLineMaterial: type cannot be changed after creation"),f[c]=k[c]);this.notifyDirty("matChanged")};this.dispose=function(){};this.getOutputAmount=function(f){return((f/2+1-2)*e+4)*d.getStride()};this.getVertexBufferLayout=function(){return d};this.fillInterleaved=function(d,c,e,m,a,b){e=d.vertexAttr[g.POSITION].data;m=d.vertexAttr[g.COLOR]?d.vertexAttr[g.COLOR].data:
O;d=d.vertexAttr[g.SIZE]?d.vertexAttr[g.SIZE].data:P;if("wall"===f.type){m=b;d=e.length/3;b=0;for(var k=e[0],l=e[1],n=e[2],r,p,h,z=0;z<d;z++){var u=3*z;r=k;p=l;h=n;k=e[u];l=e[u+1];n=e[u+2];c&&(k=c[0]*k+c[4]*l+c[8]*n+c[12],l=c[1]*k+c[5]*l+c[9]*n+c[13],n=c[2]*k+c[6]*l+c[10]*n+c[14]);b+=Math.sqrt((k-r)*(k-r)+(l-p)*(l-p)+(n-h)*(n-h));a[m++]=k;a[m++]=l;a[m++]=n;a[m++]=b;a[m++]=-1;a[m++]=k;a[m++]=l;a[m++]=n;a[m++]=b;a[m++]=1}}else{k=e.length/3;l=e[0];n=e[1];r=e[2];p=0;c&&(l=c[0]*l+c[4]*n+c[8]*r+c[12],n=
c[1]*l+c[5]*n+c[9]*r+c[13],r=c[2]*l+c[6]*n+c[10]*r+c[14]);h=l;var z=n,u=r,v=e[3],w=e[4],x=e[5];c&&(v=c[0]*v+c[4]*w+c[8]*x+c[12],w=c[1]*v+c[5]*w+c[9]*x+c[13],x=c[2]*v+c[6]*w+c[10]*x+c[14]);for(var q=0;q<k;q++){var t=3*q;q<k-1&&(v=e[t+3],w=e[t+4],x=e[t+5],c&&(v=c[0]*v+c[4]*w+c[8]*x+c[12],w=c[1]*v+c[5]*w+c[9]*x+c[13],x=c[2]*v+c[6]*w+c[10]*x+c[14]));p+=Math.sqrt((h-l)*(h-l)+(z-n)*(z-n)+(u-r)*(u-r));a[b++]=h;a[b++]=z;a[b++]=u;a[b++]=p;a[b++]=0===q?-1.2:-1;a[b++]=l;a[b++]=n;a[b++]=r;a[b++]=v;a[b++]=w;a[b++]=
x;a[b++]=m[0];a[b++]=m[1];a[b++]=m[2];a[b++]=m[3];a[b++]=d[0];a[b++]=h;a[b++]=z;a[b++]=u;a[b++]=p;a[b++]=0===q?1.2:1;a[b++]=l;a[b++]=n;a[b++]=r;a[b++]=v;a[b++]=w;a[b++]=x;a[b++]=m[0];a[b++]=m[1];a[b++]=m[2];a[b++]=m[3];a[b++]=d[0];0<q&&q<k-1&&(a[b++]=h,a[b++]=z,a[b++]=u,a[b++]=p,a[b++]=-1.2,a[b++]=l,a[b++]=n,a[b++]=r,a[b++]=v,a[b++]=w,a[b++]=x,a[b++]=m[0],a[b++]=m[1],a[b++]=m[2],a[b++]=m[3],a[b++]=d[0],a[b++]=h,a[b++]=z,a[b++]=u,a[b++]=p,a[b++]=1.2,a[b++]=l,a[b++]=n,a[b++]=r,a[b++]=v,a[b++]=w,a[b++]=
x,a[b++]=m[0],a[b++]=m[1],a[b++]=m[2],a[b++]=m[3],a[b++]=d[0]);l=h;n=z;r=u;h=v;z=w;u=x}}};this.intersect=function(d,c,e,g,a,b,q,l,n,r,p){if(p){c=d.getData().getVertexAttr("position").position.data;d=d.getData().getVertexAttr("size").size.data[0]+f.width;q=Number.MAX_VALUE;var k,m;for(l=0;l<c.length-5;l+=3){t[0]=c[l];t[1]=c[l+1];t[2]=c[l+2];L.multiplyVec3(e,t);y[0]=c[l+3];y[1]=c[l+4];y[2]=c[l+5];L.multiplyVec3(e,y);n.projectPoint(t,C);n.projectPoint(y,D);if(0>C[2]&&0<D[2]){h.subtract(t,y,A);p=n.frustumPlanes;
var u=-(h.dot(p[4],t)+p[4][3]);p=u/h.dot(A,p[4]);h.scale(A,p,A);h.add(t,A,t);n.projectPoint(t,C)}else if(0<C[2]&&0>D[2])h.subtract(y,t,A),p=n.frustumPlanes,u=-(h.dot(p[4],y)+p[4][3]),p=u/h.dot(A,p[4]),h.scale(A,p,A),h.add(y,A,y),n.projectPoint(y,D);else if(0>C[2]&&0>D[2])continue;p=F.projectVectorVector2D(C,D,g);p<q&&(q=p,k=t,m=y)}q<d/2+4&&(e=F.linelineDistance3D(k,m,a,b),g=Number.MAX_VALUE,e[0]&&(h.subtract(a,e[3],I),g=.98*h.length(I)/h.dist(a,b)),r(g,I))}};this.getGLMaterials=function(){return[Q,
void 0,void 0]};this.getAllTextureIds=function(){return[]}};var Q=function(f,h){G.basicGLMaterialConstructor(this,f);var g=M.clone(f.getParams());g.miterLimit="miter"===g.join?g.miterLimit:0;delete g.join;var e=h.get("ribbonLine_"+g.type);this.updateParameters=function(){var d=f.getParams();g.polygonOffset=d.polygonOffset;g.color=d.color;g.width=d.width;g.miterLimit="miter"===d.join?d.miterLimit:0};this.beginSlot=function(d){return 2===d};this.getProgram=function(){return e};this.bind=function(d,
k){e.use();e.uniform4fv("eColor",g.color);e.uniform1f("miterLimit",g.miterLimit);e.uniform1f("nearPlane",k.nearFar[0]);"screen"===g.type?(e.uniform2fv("screenSize",[k.viewport[2],k.viewport[3]]),e.uniform1f("extLineWidth",g.width*k.pixelRatio)):e.uniform1f("extLineWidth",g.width);f.getVertexBufferLayout().enableVertexAttribArrays(d,e);g.polygonOffset&&(d.enable(d.POLYGON_OFFSET_FILL),d.polygonOffset(0,-4));d.enable(d.BLEND);d.web3DDefaultState.cullFace&&d.disable(d.CULL_FACE);1>g.color[3]&&d.depthMask(!1)};
this.release=function(d){f.getVertexBufferLayout().disableVertexAttribArrays(d,e);g.polygonOffset&&d.disable(d.POLYGON_OFFSET_FILL);d.disable(d.BLEND);d.web3DDefaultState.cullFace&&d.enable(d.CULL_FACE);d.depthMask(!0)};this.bindView=function(d,f){G.bindView(f.origin,f.view,e)};this.bindInstance=function(d,f){e.uniformMatrix4fv("model",f.transformation)};this.getDrawMode=function(d){return d.TRIANGLE_STRIP}};B.loadShaders=function(f,h,g,e){f._parse(N);var d=new E(e.VERTEX_SHADER,f.vsRibbonLine,e,
["SCREENSCALE"]),k=new E(e.VERTEX_SHADER,f.vsRibbonLine,e);h=new E(e.VERTEX_SHADER,f.vsRibbonLine,e,["WALL"]);f=new E(e.FRAGMENT_SHADER,f.fsRibbonLine,e);d=new H([d,f],e);k=new H([k,f],e);e=new H([h,f],e);g.add("ribbonLine_screen",d);g.add("ribbonLine_strip",k);g.add("ribbonLine_wall",e)};return B});