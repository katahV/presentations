// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.8/esri/copyright.txt for details.
//>>built
require({cache:{"url:esri/views/3d/webgl-engine/lib/edgeRendering/EdgeRenderer.xml":'\x3c?xml version\x3d"1.0" encoding\x3d"UTF-8"?\x3e\n\n\x3csnippets\x3e\n\n\x3csnippet name\x3d"vsRibbonEdgeStyleOutputs"\x3e\x3c![CDATA[\n#if defined(SKETCH) || defined(UBER)\n\n  uniform vec2 uStrokesTextureScale;\n  uniform float uStrokesLog2Resolution;\n  uniform float uStrokeVariants;\n\n  varying vec2 vStrokeUV;\n  varying float vLineIndex;\n\n  void calculateStyleOutputsSketch(float lineLength, UnpackedAttributes unpackedAttributes) {\n    vec2 sidenessNorm \x3d unpackedAttributes.sidenessNorm;\n\n    float lineIndex \x3d clamp(ceil(log2(lineLength)), 0.0, uStrokesLog2Resolution);\n\n    vStrokeUV \x3d vec2(exp2(lineIndex) * sidenessNorm.y, lineIndex * uStrokeVariants + aVariantStroke + 0.5) * uStrokesTextureScale;\n    vStrokeUV.x +\x3d aVariantOffset;\n\n    vLineIndex \x3d lineIndex;\n  }\n#endif /* SKETCH || UBER */\n\n#if defined(SKETCH)\n  void calculateStyleOutputs(vec4 viewPosV0, vec4 viewPosV1, vec4 worldPosV0, vec4 worldPosV1, vec4 projPos, vec3 worldNormal, UnpackedAttributes unpackedAttributes) {\n    calculateStyleOutputsSketch(vLineLengthPixels, unpackedAttributes);\n  }\n#elif defined(SOLID)\n  void calculateStyleOutputs(vec4 viewPosV0, vec4 viewPosV1, vec4 worldPosV0, vec4 worldPosV1, vec4 projPos, vec3 worldNormal, UnpackedAttributes unpackedAttributes) {\n  }\n#elif defined(UBER)\n  varying float vType;\n\n  void calculateStyleOutputs(vec4 viewPosV0, vec4 viewPosV1, vec4 worldPosV0, vec4 worldPosV1, vec4 projPos, vec3 worldNormal, UnpackedAttributes unpackedAttributes) {\n    vType \x3d unpackedAttributes.type;\n\n    if (unpackedAttributes.type \x3c\x3d 0.0) {\n      calculateStyleOutputsSketch(vLineLengthPixels, unpackedAttributes);\n    }\n  }\n#endif /* UBER */\n\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"vsRibbonEdgeLineAmplitudeRegular"\x3e\x3c![CDATA[\n\n#if defined(UBER) || !defined(SKETCH)\n\n  float calculateLineAmplitudeRegular() {\n    return 0.0;\n  }\n\n#endif /* UBER || !SKETCH */\n\n#if !defined(UBER) \x26\x26 !defined(SKETCH)\n\n  float calculateLineAmplitude(UnpackedAttributes unpackedAttributes) {\n    return calculateLineAmplitudeRegular();\n  }\n\n#endif /* !UBER \x26\x26 !SKETCH */\n\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"vsRibbonEdgeLineAmplitudeSketch"\x3e\x3c![CDATA[\n\n#if defined(UBER) || defined(SKETCH)\n\n  uniform float uStrokesAmplitude;\n\n  float calculateLineAmplitudeSketch() {\n    return uStrokesAmplitude;\n  }\n\n#endif /* UBER || SKETCH */\n\n#ifdef SKETCH\n\n  float calculateLineAmplitude(UnpackedAttributes unpackedAttributes) {\n    return calculateLineAmplitudeSketch();\n  }\n\n#endif /* SKETCH */\n\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"vsRibbonEdgeLineAmplitudeUber"\x3e\x3c![CDATA[\n\n#ifdef UBER\n\n  float calculateLineAmplitude(UnpackedAttributes unpackedAttributes) {\n    float type \x3d unpackedAttributes.type;\n\n    if (type \x3c\x3d 0.0) {\n      return calculateLineAmplitudeSketch();\n    }\n    else {\n      return calculateLineAmplitudeRegular();\n    }\n  }\n\n#endif /* UBER */\n\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"vsRibbonEdge"\x3e\x3c![CDATA[\n  $vsprecisionf\n\n  // Transformations\n  uniform mat4 uProj;\n  uniform mat4 uView;\n  uniform mat4 uModel;\n  uniform vec3 uCameraPosition;\n\n  // Line configuration\n\n  // Conversion constants\n  uniform vec2 uPixelToNDC;\n  uniform vec2 uNDCToPixel;\n\n  // Inputs\n  attribute vec3 aPosition0;\n  attribute vec3 aPosition1;\n  attribute float aVariantOffset;\n  attribute float aVariantStroke;\n  attribute float aVariantExtension;\n\n#ifdef SILHOUETTE\n\n  attribute vec3 aNormalA;\n  attribute vec3 aNormalB;\n\n#else /* SILHOUETTE */\n\n  attribute vec3 aNormal;\n\n#endif /* SILHOUETTE */\n\nattribute vec2 aSideness;\nattribute vec2 aPackedAttributes;\n\nstruct UnpackedAttributes {\n  vec2 sideness;\n  vec2 sidenessNorm;\n  float lineWidthPixels;\n  float extensionLengthPixels;\n\n#ifdef UBER\n\n  float type;\n\n#endif\n};\n\n  // Output required to compute color\n  varying vec4 vColor;\n\n  // Output required to compute distance to line/caps\n  varying vec3 vPosition;\n  varying float vRadius;\n  varying float vLineLengthPixels;\n  varying float vSizeFalloffFactor;\n\n  $EdgeRendererUtils_adjustProjectedPosition\n\n  $vsRibbonEdgeStyleOutputs\n\n  $vsRibbonEdgeLineAmplitudeRegular\n  $vsRibbonEdgeLineAmplitudeSketch\n  $vsRibbonEdgeLineAmplitudeUber\n\n  $EdgeRendererUtils_readComponentData\n  $EdgeRendererUtils_distanceBasedPerspectiveFactor\n  $EdgeRendererUtils_worldNormal\n  $EdgeRendererUtils_extensionFalloff\n\n#ifdef SILHOUETTE\n\n  $EdgeRendererUtils_isSilhouetteEdge\n\n#endif /* SILHOUETTE */\n\n  vec4 calculateGeometricOutputs(vec4 viewPosV0, vec4 viewPosV1, vec4 worldPosV0, vec4 worldPosV1, vec3 worldNormal, UnpackedAttributes unpackedAttributes) {\n    vec2 sideness \x3d unpackedAttributes.sideness;\n    vec2 sidenessNorm \x3d unpackedAttributes.sidenessNorm;\n\n    vec4 viewPos \x3d mix(viewPosV0, viewPosV1, sidenessNorm.y);\n    vec4 projPosV0 \x3d uProj * viewPosV0;\n    vec4 projPosV1 \x3d uProj * viewPosV1;\n    vec4 projPos \x3d uProj * viewPos;\n\n    vec3 screenSpaceLineNDC \x3d (projPosV1.xyz / projPosV1.w - projPosV0.xyz / projPosV0.w);\n    vec2 screenSpaceLinePixels \x3d screenSpaceLineNDC.xy * uNDCToPixel;\n    float lineLengthPixels \x3d length(screenSpaceLinePixels);\n\n    float dzPerPixel \x3d screenSpaceLineNDC.z / lineLengthPixels;\n    vec2 screenSpaceDirection \x3d screenSpaceLinePixels / lineLengthPixels;\n    vec2 perpendicularScreenSpaceDirection \x3d vec2(screenSpaceDirection.y, -screenSpaceDirection.x) * sideness.x;\n\n    float falloffFactor \x3d distanceBasedPerspectiveFactor(-viewPos.z);\n    float lineWidthPixels \x3d unpackedAttributes.lineWidthPixels * falloffFactor;\n\n    float extensionLengthPixels \x3d calculateExtensionLength(unpackedAttributes.extensionLengthPixels, lineLengthPixels) * falloffFactor;\n    float lineAmplitudePixels \x3d calculateLineAmplitude(unpackedAttributes);\n\n    vSizeFalloffFactor \x3d falloffFactor;\n\n    float lineWidthAndAmplitudePixels \x3d lineWidthPixels + lineAmplitudePixels + lineAmplitudePixels;\n    float extendedLineLengthPixels \x3d lineLengthPixels + extensionLengthPixels + extensionLengthPixels;\n\n#ifdef ANTIALIASING\n\n    const float aaPaddingPixels \x3d 1.0;\n\n    // Line size with padding\n    float halfAAPaddedLineWidthAndAmplitudePixels \x3d lineWidthAndAmplitudePixels * 0.5 + aaPaddingPixels;\n    float aaPaddedRoundedCapSizePixels \x3d lineWidthPixels * 0.5 + aaPaddingPixels;\n\n    // Line length with padding\n    float aaPaddedLineLengthPixels \x3d extendedLineLengthPixels + aaPaddingPixels + aaPaddingPixels;\n    float halfAAPaddedLineLengthPixels \x3d aaPaddedLineLengthPixels * 0.5;\n\n#else /* ANTIALIASING */\n\n    // Even if there is no AA, we still want to do proper \x3c1px rendering,\n    // so we effectively clamp the pixel sizes to minimum of 1px and compute\n    // coverage in the fragment shader\n    float halfAAPaddedLineWidthAndAmplitudePixels \x3d max(lineWidthAndAmplitudePixels, 1.0) * 0.5;\n    float aaPaddedRoundedCapSizePixels \x3d max(lineWidthPixels, 1.0) * 0.5;\n\n    float halfAAPaddedLineLengthPixels \x3d max(extendedLineLengthPixels, 1.0) * 0.5;\n\n#endif /* ANTIALIASING */\n\n    // Half line width in NDC including padding for anti aliasing\n    vec2 halfAAPaddedLineWidthAndAmplitudeNDC \x3d halfAAPaddedLineWidthAndAmplitudePixels * uPixelToNDC;\n    vec2 aaPaddedRoundedCapSizeNDC \x3d aaPaddedRoundedCapSizePixels * uPixelToNDC;\n    vec2 extensionLengthNDC \x3d extensionLengthPixels * uPixelToNDC;\n\n    // Compute screen space position of vertex, offsetting for line size and end caps\n    vec2 ndcOffset \x3d (\n        screenSpaceDirection * sideness.y * (aaPaddedRoundedCapSizeNDC + extensionLengthNDC)\n      + perpendicularScreenSpaceDirection * halfAAPaddedLineWidthAndAmplitudeNDC\n    );\n\n    projPos.xy +\x3d ndcOffset * projPos.w;\n    projPos.z +\x3d (dzPerPixel * (aaPaddedRoundedCapSizePixels + extensionLengthPixels)) * sideness.y * projPos.w;\n\n    projPos \x3d adjustProjectedPosition(projPos, worldNormal, 1.0 + max((lineWidthAndAmplitudePixels - 1.0) * 0.5, 0.0));\n\n    // Line length with end caps\n    float aaPaddedLineWithCapsLengthPixels \x3d extendedLineLengthPixels + aaPaddedRoundedCapSizePixels + aaPaddedRoundedCapSizePixels;\n\n    float pixelPositionAlongLine \x3d aaPaddedLineWithCapsLengthPixels * sidenessNorm.y - aaPaddedRoundedCapSizePixels;\n\n    // Position in pixels with origin at first vertex of line segment\n    vPosition \x3d vec3(\n      halfAAPaddedLineWidthAndAmplitudePixels * sideness.x,\n      pixelPositionAlongLine,\n      pixelPositionAlongLine / extendedLineLengthPixels\n    );\n\n    // The line width radius in pixels\n    vRadius \x3d lineWidthPixels * 0.5;\n    vLineLengthPixels \x3d extendedLineLengthPixels;\n\n#ifdef SILHOUETTE\n\n    gl_Position \x3d isSilhouetteEdge(viewPosV0, aNormalA, aNormalB) ? projPos : vec4(10, 10, 10, 1);\n\n#else /* SILHOUETTE */\n\n    gl_Position \x3d projPos;\n\n#endif /* SILHOUETTE */\n\n#ifdef UBER\n\n    if (unpackedAttributes.type \x3c\x3d 0.0 \x26\x26 lineLengthPixels \x3c\x3d 3.0) {\n      gl_Position \x3d vec4(10, 10, 10, 1);\n    }\n\n#elif defined(SKETCH)\n\n    if (lineLengthPixels \x3c\x3d 3.0) {\n      gl_Position \x3d vec4(10, 10, 10, 1);\n    }\n\n#endif\n\n    return projPos;\n  }\n\n#ifdef UBER\n\n  UnpackedAttributes unpackAttributes(ComponentData component) {\n\n    vec2 sidenessNorm \x3d aSideness;\n    vec2 sideness \x3d sidenessNorm * 2.0 - 1.0;\n\n    float fType \x3d component.type;\n    float extensionLengthPixels \x3d component.extensionLength;\n    float lineWidth \x3d component.lineWidth;\n\n    if (fType \x3c\x3d 0.0) {\n      extensionLengthPixels *\x3d aVariantExtension * 2.0 - 1.0;\n    }\n\n    return UnpackedAttributes(sideness, sidenessNorm, lineWidth, extensionLengthPixels, fType);\n  }\n\n#else /* UBER */\n\n  UnpackedAttributes unpackAttributes(ComponentData component) {\n    vec2 sidenessNorm \x3d aSideness;\n    vec2 sideness \x3d sidenessNorm * 2.0 - 1.0;\n    float extensionLengthPixels \x3d component.extensionLength;\n\n#ifdef SKETCH\n\n    extensionLengthPixels *\x3d aVariantExtension * 2.0 - 1.0;\n\n#endif /* SKETCH */\n\n    float lineWidth \x3d component.lineWidth;\n\n    return UnpackedAttributes(sideness, sidenessNorm, lineWidth, extensionLengthPixels);\n  }\n\n#endif /* UBER */\n\n  void main() {\n    ComponentData component \x3d readComponentData();\n    UnpackedAttributes unpackedAttributes \x3d unpackAttributes(component);\n\n    vec4 worldPosV0 \x3d uModel * vec4(aPosition0, 1.0);\n    vec4 worldPosV1 \x3d uModel * vec4(aPosition1, 1.0);\n\n    vec4 viewPosV0 \x3d uView * worldPosV0;\n    vec4 viewPosV1 \x3d uView * worldPosV1;\n\n#ifdef SILHOUETTE\n\n    vec3 worldNormal \x3d silhouetteWorldNormal(aNormalA, aNormalB);\n\n#else /* SILHOUETTE */\n\n    vec3 worldNormal \x3d modelToWorldNormal(aNormal);\n\n#endif /* SILHOUETTE */\n\n    // General geometric computation for all types of edges\n    vec4 projPos \x3d calculateGeometricOutputs(viewPosV0, viewPosV1, worldPosV0, worldPosV1, worldNormal, unpackedAttributes);\n\n    // Component color\n    vColor \x3d component.color;\n\n    // Specific computation for different edge styles\n    calculateStyleOutputs(viewPosV0, viewPosV1, worldPosV0, worldPosV1, projPos, worldNormal, unpackedAttributes);\n  }\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"fsRibbonEdgeLineOffsetSketch"\x3e\x3c![CDATA[\n\n$rgba2float\n\n#if defined(UBER) || defined(SKETCH)\n\n  uniform sampler2D uStrokesTexture;\n  uniform float uStrokesNormalizationScale;\n\n  varying vec2 vStrokeUV;\n\n  float calculateLineOffsetSketch() {\n    float offsetNorm \x3d rgba2float(texture2D(uStrokesTexture, vStrokeUV));\n    return (offsetNorm - 0.5) * uStrokesNormalizationScale;\n  }\n\n  float calculateLinePressureSketch() {\n    return rgba2float(texture2D(uStrokesTexture, vStrokeUV + vec2(0, 0.5)));\n  }\n\n#endif /* UBER || SKETCH */\n\n#ifdef SKETCH\n\n  float calculateLineOffset() {\n    return calculateLineOffsetSketch();\n  }\n\n  float calculateLinePressure() {\n    return calculateLinePressureSketch();\n  }\n\n#endif /* SKETCH */\n\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"fsRibbonEdgeLineOffsetRegular"\x3e\x3c![CDATA[\n\n#if defined(UBER) || !defined(SKETCH)\n\n  float calculateLineOffsetRegular() {\n    return 0.0;\n  }\n\n  float calculateLinePressureRegular() {\n    return 1.0;\n  }\n\n#endif /* UBER || !SKETCH */\n\n#if !defined(UBER) \x26\x26 !defined(SKETCH)\n\n  float calculateLineOffset() {\n    return calculateLineOffsetRegular();\n  }\n\n  float calculateLinePressure() {\n    return calculateLinePressureRegular();\n  }\n\n#endif /* !UBER || !SKETCH */\n\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"fsRibbonEdgeLineOffsetUber"\x3e\x3c![CDATA[\n\n#ifdef UBER\n  varying float vType;\n\n  float calculateLineOffset() {\n    if (vType \x3c\x3d 0.0) {\n      return calculateLineOffsetSketch();\n    }\n    else {\n      return calculateLineOffsetRegular();\n    }\n  }\n\n  float calculateLinePressure() {\n    if (vType \x3c\x3d 0.0) {\n      return calculateLinePressureSketch();\n    }\n    else {\n      return calculateLinePressureRegular();\n    }\n  }\n#endif /* UBER */\n\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"fsRibbonEdge"\x3e\x3c![CDATA[\n  $fsprecisionf\n\n  varying vec4 vColor;\n  varying float vRadius;\n  varying vec3 vPosition;\n  varying float vLineLengthPixels;\n  varying float vSizeFalloffFactor;\n  varying float vLineIndex;\n\n  // At which coverage threshold we discard a fragment completely\n  #define COVERAGE_TEST_THRESHOLD 0.01\n\n  $fsRibbonEdgeLineOffsetRegular\n  $fsRibbonEdgeLineOffsetSketch\n  $fsRibbonEdgeLineOffsetUber\n\n  vec2 lineWithCapsDistance(float radius, vec2 position, float lineLength) {\n    float lineOffset \x3d calculateLineOffset();\n    float positionX \x3d position.x - lineOffset;\n\n    if (radius \x3c 1.0) {\n      // Handle this specifically for subpixel sizes:\n      // 1. Compute correct coverage (note coverage is computed by\n      //    0.5 - dist, so we make sure that that will lead to correct\n      //    subpixel coverage\n      // 2. Ignore rounded caps\n      float coverageX \x3d clamp(min(radius, positionX + 0.5) - max(-radius, positionX - 0.5), 0.0, 1.0);\n      float coverageY \x3d clamp(min(lineLength, position.y + 0.5) - max(0.0, position.y - 0.5), 0.0, 1.0);\n\n      float coverage \x3d min(coverageX, coverageY);\n\n      return vec2(0.5 - coverage, 0.0);\n    }\n    else {\n      // Between -radius -\x3e 0 for start cap, 0 for line, 0 -\x3e radius\n      float positionOnCap \x3d position.y - clamp(position.y, 0.0, lineLength);\n\n      vec2 lineToPosition \x3d vec2(positionX, positionOnCap);\n      return vec2(length(lineToPosition) - radius, positionOnCap / radius);\n    }\n  }\n\n  void main() {\n\n    float radius \x3d vRadius * calculateLinePressure();\n\n    vec2 distance \x3d lineWithCapsDistance(radius, vPosition.xy, vLineLengthPixels);\n    float coverage \x3d clamp(0.5 - distance.x, 0.0, 1.0);\n\n#ifdef ANTIALIASING\n\n    const float coverageLimit \x3d COVERAGE_TEST_THRESHOLD;\n\n#else /* ANTIALIASING */\n\n    // Use subpixel coverage computation when lines get subpixel widths\n    // so we still render them appropriately. Otherwise discard anything\n    // that is not fully within the line\n    float coverageLimit \x3d radius \x3c\x3d 0.5 ? COVERAGE_TEST_THRESHOLD : 0.75;\n\n#endif /* ANTIALIASING */\n\n    if (coverage \x3c coverageLimit) {\n      discard;\n    }\n\n    float alpha \x3d vColor.a * coverage;\n\n    gl_FragColor \x3d vec4(vColor.rgb, alpha);\n  }\n]]\x3e\x3c/snippet\x3e\n\n\x3c/snippets\x3e\n',
"url:esri/views/3d/webgl-engine/lib/edgeRendering/EdgeRendererUtils.xml":'\x3c?xml version\x3d"1.0" encoding\x3d"UTF-8"?\x3e\n\n\x3csnippets\x3e\n\n\x3csnippet name\x3d"EdgeRendererUtils_distanceBasedPerspectiveFactor"\x3e\x3c![CDATA[\n  uniform float uDistanceFalloffFactor;\n\n  float distanceBasedPerspectiveFactor(float distance) {\n    return clamp(sqrt(uDistanceFalloffFactor / distance), 0.0, 1.0);\n  }\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"EdgeRendererUtils_readComponentData"\x3e\x3c![CDATA[\n  uniform sampler2D uComponentDataTex;\n  uniform vec2 uComponentDataTexInvDim;\n\n  attribute float aComponentIndex;\n\n  #define COMPONENT_COLOR_FIELD_OFFSET 0.0\n  #define COMPONENT_OTHER_FIELDS_OFFSET 1.0\n  #define COMPONENT_FIELD_COUNT 2.0\n\n  #define LINE_WIDTH_FRACTION_FACTOR 8.0\n  #define EXTENSION_LENGTH_OFFSET 128.0\n\n  #define COMPONENT_TEX_WIDTH 4096.0\n\n  vec2 componentTextureCoords(float componentIndex, float fieldOffset) {\n    float fieldIndex \x3d COMPONENT_FIELD_COUNT * componentIndex + fieldOffset;\n\n    float rowIndex \x3d floor(fieldIndex / COMPONENT_TEX_WIDTH);\n    float colIndex \x3d mod(fieldIndex, COMPONENT_TEX_WIDTH);\n\n    vec2 linearIndex \x3d vec2(\n      (colIndex + 0.5) / COMPONENT_TEX_WIDTH,\n      (rowIndex + 0.5) * uComponentDataTexInvDim.y\n    );\n\n    return linearIndex;\n  }\n\n  struct ComponentData {\n    vec4 color;\n    float lineWidth;\n    float extensionLength;\n    float type;\n  };\n\n  ComponentData readComponentData() {\n    vec2 colorIndex \x3d componentTextureCoords(aComponentIndex, COMPONENT_COLOR_FIELD_OFFSET);\n    vec2 otherIndex \x3d componentTextureCoords(aComponentIndex, COMPONENT_OTHER_FIELDS_OFFSET);\n\n    vec4 colorValue \x3d texture2D(uComponentDataTex, colorIndex);\n    vec4 otherValue \x3d texture2D(uComponentDataTex, otherIndex);\n\n    return ComponentData(\n      vec4(colorValue.rgb, colorValue.a * otherValue.w), // otherValue.w stores separate opacity\n      otherValue.x * (255.0 / LINE_WIDTH_FRACTION_FACTOR),\n      otherValue.y * 255.0 - EXTENSION_LENGTH_OFFSET,\n      -(otherValue.z * 255.0) + 0.5 // SOLID (\x3d0/255) needs to be \x3e 0.0, SKETCHY (\x3d1/255) needs to be \x3c\x3d 0;\n    );\n  }\n\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"EdgeRendererUtils_isSilhouetteEdge"\x3e\x3c![CDATA[\n  // #uniforms: uView, uModel\n  bool isSilhouetteEdge(vec4 viewPos, vec3 normalA, vec3 normalB) {\n    // transform the two face normals\n    vec3 viewNormalA \x3d (uView * uModel * vec4(normalA, 0.0)).xyz;\n    vec3 viewNormalB \x3d (uView * uModel * vec4(normalB, 0.0)).xyz;\n\n    // compute the direction from the edge to the camera\n    vec3 viewDir \x3d -viewPos.xyz;\n\n    // check which of the two faces are visible\n    // display the edge if exactly one of the two is visible\n    float faceAVisible \x3d dot(viewDir, viewNormalA); // positive if visible\n    float faceBVisible \x3d dot(viewDir, viewNormalB); // positive if visible\n\n    // 1 if exactly one face visible, 0 otherwise\n    return faceAVisible * faceBVisible \x3c 0.0;\n  }\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"EdgeRendererUtils_adjustProjectedPosition"\x3e\x3c![CDATA[\n  uniform vec2 uDepthBias;\n  uniform vec2 uViewportDimInv;\n\n  // Utility function to check for NaN values\n  bool isNaN(float val) {\n    return ( val \x3c 0.0 || 0.0 \x3c val || val \x3d\x3d 0.0 ) ? false : true;\n    // important: some nVidias failed to cope with version below.\n    // Probably wrong optimization.\n    /*return ( val \x3c\x3d 0.0 || 0.0 \x3c\x3d val ) ? false : true;*/\n  }\n\n  // An offset in xy screen space, along the projected normal of the edge\n  // This reduces depth fighting when looking at a face from a flat angle\n  vec2 calculateProjectedBiasXY(vec4 projPos, vec3 worldNormal) {\n    float offsetXY \x3d uDepthBias.x;\n    float offsetZ  \x3d uDepthBias.y;\n\n    // screen space pixel offset\n    // we multiply by two to account for the fact that NDC go from -1 to 1\n    // we multiply by projPos.w to compensate for the perspective divison that happens later\n    // normalizing over xyz means that the xy influence is reduced the more the normal is pointing\n    // towards the camera\n    vec4 projNormal \x3d uProj * uView * vec4(worldNormal, 0.0);\n\n    return offsetXY * projPos.w * 2.0 * uViewportDimInv * normalize(projNormal.xyz).xy;\n  }\n\n  // A z-offset, using a depth based heuristic.\n  float calculateProjectedBiasZ(vec4 projPos) {\n    float offsetZ \x3d uDepthBias.y;\n    return sqrt(projPos.z) * offsetZ;\n  }\n\n  vec4 adjustProjectedPosition(vec4 projPos, vec3 worldNormal, float lineWidth) {\n    vec2 offsetXY \x3d calculateProjectedBiasXY(projPos, worldNormal);\n\n    // we currently have to do this check because some geometries come with 0 length edge normals.\n    // see https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/12890\n    if (!isNaN(offsetXY.x) \x26\x26 !isNaN(offsetXY.y)) {\n      projPos.xy +\x3d offsetXY;\n    }\n\n    projPos.z +\x3d calculateProjectedBiasZ(projPos) * lineWidth;\n\n    return projPos;\n  }\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"EdgeRendererUtils_worldNormal"\x3e\x3c![CDATA[\n  vec3 modelToWorldNormal(vec3 normal) {\n    return (uModel * vec4(normal, 0)).xyz;\n  }\n\n  vec3 silhouetteWorldNormal(vec3 normalA, vec3 normalB) {\n    return modelToWorldNormal(normalize(normalA + normalB));\n  }\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"EdgeRendererUtils_extensionFalloff"\x3e\x3c![CDATA[\n  // Fall-off extension length for shorter strokes, starting from strokes that are 256 size,\n  // fall-off exponentially\n  float calculateExtensionLength(float extensionLength, float lineLength) {\n    return extensionLength / (log2(max(1.0, 256.0 / lineLength)) * 0.2 + 1.0);\n  }\n]]\x3e\x3c/snippet\x3e\n\n\x3c/snippets\x3e\n'}});
define("require exports ../../../../../core/tsSupport/assignHelper ../../../../../core/tsSupport/extendsHelper dojo/text!./EdgeRenderer.xml dojo/text!./EdgeRendererUtils.xml ../../../lib/glMatrix ../../../support/mathUtils ../ShaderVariations ./bufferLayouts".split(" "),function(g,d,l,u,m,n,h,p,q,k){Object.defineProperty(d,"__esModule",{value:!0});d.LINE_WIDTH_FRACTION_FACTOR=8;d.EXTENSION_LENGTH_OFFSET=128;var r={type:"solid",uber:!0,strokesTexture:null},t=function(){function b(){this._value=0}Object.defineProperty(b.prototype,
"value",{get:function(){return this._value},enumerable:!0,configurable:!0});b.prototype.increment=function(){this._value++};b.prototype.decrement=function(){this._value--};return b}();g=function(){function b(a,c,f){this.rctx=a;this.programRepository=c;this.refCount=new t;this.renderables=new Set;this.depthBiasZ=-4E-4;this.depthBiasXY=.5;this.tmpViewToWorldNormalMatrix=h.mat3d.create();this.settings=l({},r,f);this.key=b.getKey(this.settings.uber,this.settings.type);this.writerSettings={variants:this.settings.strokesTexture.variants};
this.createPrograms()}b.prototype.dispose=function(){for(var a in this.programs){var c=this.programs[a];c&&(this.programRepository.decreaseRefCount(c),this.programs[a]=null)}};b.prototype.addRenderable=function(a){this.renderables.add(a)};b.prototype.removeRenderable=function(a){this.renderables.delete(a)};b.prototype.forEachRenderable=function(a){this.renderables.forEach(a)};b.prototype.bindRegularEdges=function(a,c){this.bind(this.programs.regular,a,c)};b.prototype.bindSilhouetteEdges=function(a,
c){this.bind(this.programs.silhouette,a,c)};b.prototype.bind=function(a,c,b){this.rctx.bindProgram(a);a.setUniformMatrix4fv("uProj",c.proj);a.setUniform2f("uDepthBias",this.depthBiasXY,this.depthBiasZ);a.setUniform2f("uPixelToNDC",2/c.viewport[2],2/c.viewport[3]);a.setUniform2f("uNDCToPixel",c.viewport[2]/2,c.viewport[3]/2);a.setUniform1f("uDistanceFalloffFactor",b.distanceFalloffFactor);a.setUniform2f("uViewportDimInv",1/c.viewport[2],1/c.viewport[3])};b.prototype.renderRegularEdges=function(a,c,
b){this.render(this.programs.regular,a,a.regular.vao,c,b)};b.prototype.renderSilhouetteEdges=function(a,c,b){this.render(this.programs.silhouette,a,a.silhouette.vao,c,b)};b.prototype.render=function(a,c,b,d,e){this.setUniforms(a,c,d);a=this.rctx;a.bindVAO(b);a.capabilities.instancing.drawArraysInstanced(6,0,4,e)};b.prototype.setUniforms=function(a,c,b){c.components.buffer.textureBuffer.bind(a,d.componentDataBindParameters);a.setUniformMatrix4fv("uView",b.view);a.setUniformMatrix4fv("uModel",c.transform.modelMatrix);
var f=b.viewInvTransp,e=h.mat4d.toMat3(f,this.tmpViewToWorldNormalMatrix);a.setUniform3f("uCameraPosition",f[3],f[7],f[11]);a.setUniformMatrix3fv("uViewToWorldNormalMatrix",e);(this.settings.uber||"sketch"===this.settings.type)&&this.setSketchUniforms(a);a.setUniform1f("uWorldLineRadiusPerDistance",Math.tan(b.fovY/2)/(b.viewport[3]/2));a.setUniform3fv("uLocalOrigin",c.transform.origin.vec3)};b.prototype.setSketchUniforms=function(a){var c=this.settings.strokesTexture,b=c.texture;this.rctx.bindTexture(b,
0);a.setUniform1i("uStrokesTexture",0);a.setUniform2f("uStrokesTextureScale",1/b.descriptor.width,1/b.descriptor.height);a.setUniform1f("uStrokesLog2Resolution",p.log2(c.resolution));a.setUniform1f("uStrokesNormalizationScale",c.normalizationScale);a.setUniform1f("uStrokesAmplitude",c.amplitude);a.setUniform1f("uStrokeVariants",c.variants)};b.prototype.getDefines=function(a){return[a.silhouette,!!this.rctx.capabilities.blendMinMax,"solid"===this.settings.type&&!this.settings.uber,"sketch"===this.settings.type&&
!this.settings.uber,this.settings.uber]};b.prototype.createPrograms=function(){var a=this.programRepository.getShaderVariationsProgram(e,this.getDefines({silhouette:!1}),void 0,void 0,k.EdgeShaderAttributeLocations),c=this.programRepository.getShaderVariationsProgram(e,this.getDefines({silhouette:!0}),void 0,void 0,k.EdgeShaderAttributeLocations);this.programRepository.increaseRefCount(a);this.programRepository.increaseRefCount(c);this.programs={regular:a,silhouette:c}};b.loadShaders=function(a,c,
b){a.EdgeRendererUtils_readComponentColor||a._parse(n);a.fsRibbonEdge||a._parse(m);c.getShaderVariations(e)||(a=new q("ribbonEdge",["vsRibbonEdge","fsRibbonEdge"],null,c,a,b),a.addDefine("Silhouette","SILHOUETTE"),a.addDefine("AntiAliasing","ANTIALIASING"),a.addDefine("Solid","SOLID"),a.addDefine("Sketch","SKETCH"),a.addDefine("Uber","UBER"),c.addShaderVariations(e,a))};b.getKey=function(a,b){return a?"edges-uber":"edges-t:"+b};return b}();d.EdgeRenderer=g;var e="edge-shader-variations";d.componentDataBindParameters=
{texName:"uComponentDataTex",invDimName:"uComponentDataTexInvDim",unit:2}});