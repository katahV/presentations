// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.8/esri/copyright.txt for details.
//>>built
require({cache:{"url:esri/views/3d/webgl-engine/materials/DefaultMaterial.xml":'\x3c?xml version\x3d"1.0" encoding\x3d"UTF-8"?\x3e\n\n\x3csnippets\x3e\n\n\x3csnippet name\x3d"calculateVerticalOffset"\x3e\x3c![CDATA[\n  $viewingMode\n\n#ifdef VERTICAL_OFFSET\n  // [ verticalOffsetPerDistance, minWorldLength, maxWorldLength ]\n  uniform vec4 verticalOffset;\n\n#ifdef SCREEN_SIZE_PERSPECTIVE\n\n  uniform vec4 screenSizePerspectiveAlignment;\n\n  $screenSizePerspective\n\n#endif\n\n  vec3 calculateVerticalOffset(vec3 worldPos, vec3 localOrigin) {\n    float viewDistance \x3d length((view * vec4(worldPos, 1)).xyz);\n    float verticalOffsetOffsetDistance \x3d verticalOffset.x * viewDistance;\n\n#ifdef VIEWING_MODE_GLOBAL\n    vec3 worldNormal \x3d normalize(worldPos + localOrigin);\n#else\n    vec3 worldNormal \x3d vec3(0, 0, 1);\n#endif\n\n#ifdef SCREEN_SIZE_PERSPECTIVE\n    float cosAngle \x3d dot(worldNormal, normalize(worldPos - camPos));\n\n    float verticalOffsetScreenHeight \x3d screenSizePerspectiveScaleFloat(verticalOffset.x, abs(cosAngle), viewDistance, screenSizePerspectiveAlignment);\n#else\n    float verticalOffsetScreenHeight \x3d verticalOffset.x;\n#endif\n\n    // Screen sized offset in world space, used for example for line callouts\n    float worldOffset \x3d clamp(verticalOffsetScreenHeight * verticalOffset.y * viewDistance, verticalOffset.z, verticalOffset.w);\n\n    return worldNormal * worldOffset;\n  }\n#endif\n]]\x3e\n\x3c/snippet\x3e\n\n\x3csnippet name\x3d"vsPhongSrc"\x3e\x3c![CDATA[\n  uniform mat4 proj;\n  uniform mat4 view;\n  uniform vec3 camPos;\n\n  uniform vec3 localOrigin;\n\n#ifdef INSTANCED\n    attribute mat4 model;\n    attribute mat4 modelNormal;\n#else\n  uniform mat4 model;\n  uniform mat4 modelNormal;\n#endif\n#ifdef INSTANCEDCOLOR\n  attribute vec4 instanceColor;\n#endif\n  attribute vec3 $position;\n#ifdef COMPRESSED_NORMALS\n  attribute vec2 $normalCompressed;\n#else\n  attribute vec3 $normal;\n#endif\n  varying vec3 vpos;\n  varying vec3 vnormal;\n\n#ifdef COMPONENTCOLORS\n  uniform sampler2D uComponentColorTex;\n  uniform vec2 uComponentColorTexInvDim;\n\n  attribute float $componentIndex;\n\n  vec4 readComponentColor() {\n    float normalizedIndex \x3d ($componentIndex + 0.5) * uComponentColorTexInvDim.x;\n    vec2 indexCoord \x3d vec2(\n      mod(normalizedIndex, 1.0),\n      (floor(normalizedIndex) + 0.5) * uComponentColorTexInvDim.y\n    );\n    return texture2D(uComponentColorTex, indexCoord);\n  }\n#endif\n\n#ifdef RECEIVE_SHADOWS\n  varying float linearDepth;\n#endif\n\n#ifdef VERTEXCOLORS\n  attribute vec4 $color;\n#endif\n\n#ifdef SYMBOLVERTEXCOLORS\n  attribute vec4 $symbolColor;\n#endif\n\n#if defined(VV_SIZE) || defined(VV_COLOR)\n  attribute vec4 instanceFeatureAttribute;\n#endif\n\n$vvUniforms\n\n#if defined(VERTEXCOLORS)\n  varying vec4 vcolor;\n#endif\n\n  // Workaround for https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/13452\n  // We pass the externalColor uniform from VS to FS through the vcolorExt varying because\n  // there is a driver bug for Intel Integrated Graphics which led to rendering artifacts\n  // since the introduction of https://devtopia.esri.com/WebGIS/arcgis-js-api/pull/12673\n  // This should be further cleaned up later with through the following issue:\n  // https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/12763\n  uniform vec4 externalColor;\n  varying vec4 vcolorExt;\n\n#if defined(SYMBOLVERTEXCOLORS) || defined(COMPONENTCOLORS)\n  varying mediump float colorMixMode; // varying int is not supported in WebGL\n#endif\n\n  $vvFunctions\n\n  $colorMixMode\n\n  $calculateVerticalOffset\n\n  $decodeNormal\n\n  void main(void) {\n\n#ifdef VV_CUSTOM_MODEL_MATRIX\n\n    vpos \x3d (model * vvTransformPosition($position, instanceFeatureAttribute)).xyz;\n\n#ifdef COMPRESSED_NORMALS\n    vnormal \x3d normalize((modelNormal * vvTransformNormal(decodeNormal($normalCompressed), instanceFeatureAttribute)).xyz);\n#else\n    vnormal \x3d normalize((modelNormal * vvTransformNormal($normal, instanceFeatureAttribute)).xyz);\n#endif\n\n#ifdef VERTICAL_OFFSET\n    vec3 centerPos \x3d (model * vvTransformPosition(vec3(0, 0, 0), instanceFeatureAttribute)).xyz;\n#endif\n\n#else /* VV_CUSTOM_MODEL_MATRIX */\n\n    vpos \x3d (model * vec4($position, 1.0)).xyz;\n#ifdef COMPRESSED_NORMALS\n    vnormal \x3d normalize((modelNormal * vec4(decodeNormal($normalCompressed), 1.0)).xyz);\n#else\n    vnormal \x3d normalize((modelNormal * vec4($normal, 1.0)).xyz);\n#endif\n\n#ifdef VERTICAL_OFFSET\n    vec3 centerPos \x3d (model * vec4(vec3(0, 0, 0), 1.0)).xyz;\n#endif\n\n#endif /* VV_CUSTOM_MODEL_MATRIX */\n\n#ifdef VERTICAL_OFFSET\n    vpos +\x3d calculateVerticalOffset(centerPos, localOrigin);\n#endif\n\n    gl_Position \x3d proj * view * vec4(vpos, 1.0);\n\n#ifdef RECEIVE_SHADOWS\n    // Shadowmap\'s cascading index used to be based on \'1.0 / gl_FragCoord.w\'\n    // (i.e. the perspective interpolation of \'gl_Position.w\'). Precision\n    // issues on iPad/iPhone with the \'w\' component require the depth to be\n    // passed as varying to properly drive the cascading shadow map index.\n    linearDepth \x3d gl_Position.w;\n#endif\n\n#ifdef VERTEXCOLORS\n    vcolor \x3d $color * 0.003921568627451; // \x3d 1/255\n#endif\n\n    vcolorExt \x3d externalColor;\n\n#ifdef INSTANCEDCOLOR\n    vcolorExt *\x3d instanceColor;\n#endif\n#ifdef VV_COLOR\n    vcolorExt *\x3d vvGetColor(instanceFeatureAttribute, vvColorValues, vvColorColors);\n#endif\n#ifdef SYMBOLVERTEXCOLORS\n    int symbolColorMixMode;\n    vcolorExt *\x3d decodeSymbolColor(symbolColor, symbolColorMixMode) * 0.003921568627451; // \x3d 1/255;\n    colorMixMode \x3d float(symbolColorMixMode) + 0.5; // add 0.5 to avoid interpolation artifacts\n#endif\n#ifdef COMPONENTCOLORS\n    int symbolColorMixMode;\n    vcolorExt *\x3d decodeSymbolColor(readComponentColor() * 255.0, symbolColorMixMode) * 0.003921568627451; // \x3d 1/255;\n    colorMixMode \x3d float(symbolColorMixMode) + 0.5; // add 0.5 to avoid interpolation artifacts\n#endif\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"fsPhongSrc"\x3e\x3c![CDATA[\n  $fsprecisionf\n\n  uniform vec3 camPos;\n  uniform vec3 localOrigin;\n\n  $sceneLightingDefinitions\n  $sceneLightingAdditionalLightGlobal\n\n  // material parameters\n  //////////////////////////////////////////\n  uniform vec3 ambient;\n  uniform vec3 diffuse;\n  uniform vec3 specular;\n  uniform float opacity;\n  uniform float layerOpacity;\n\n#if defined(SYMBOLVERTEXCOLORS) || defined(COMPONENTCOLORS)\n  varying mediump float colorMixMode; // varying int is not supported in WebGL\n#else\n  uniform int colorMixMode;\n#endif\n\n#ifdef RECEIVE_SHADOWS\n  uniform sampler2D depthTex;\n  uniform int shadowMapNum;\n  uniform vec4 shadowMapDistance;\n  uniform mat4 shadowMapMatrix[4];\n  uniform float depthHalfPixelSz;\n#endif\n\n#ifdef RECEIVE_SSAO\n  uniform sampler2D ssaoTex;\n  uniform vec4 viewportPixelSz;\n#endif\n\n\n  varying vec3 vpos;\n  varying vec3 vnormal;\n#if defined(VERTEXCOLORS)\n  varying vec4 vcolor;\n#endif\n  varying vec4 vcolorExt;\n\n#ifdef RECEIVE_SHADOWS\n  varying float linearDepth;\n  $evalShadow\n#endif\n\n  $colorMixMode\n\n  void main() {\n    vec3 viewDir \x3d normalize(vpos - camPos);\n\n    $computeNormal\n\n    vec3 reflDir \x3d normalize(reflect(viewDir, normal));\n\n    // compute ssao\n    #ifdef RECEIVE_SSAO\n        float ssao \x3d texture2D(ssaoTex, (gl_FragCoord.xy - viewportPixelSz.xy) * viewportPixelSz.zw).a;\n        ssao \x3d viewportPixelSz.z \x3c 0.0 ? 1.0 : ssao;\n    #else\n        float ssao \x3d 1.0;\n    #endif\n\n    // At global scale we create some additional ambient light based on the main light to simulate global illumination\n    float additionalAmbientScale;\n    vec3 additionalLight \x3d sceneLightingAdditionalLightGlobal(vpos + localOrigin, ssao, additionalAmbientScale);\n\n    // compute shadowing\n    float shadow \x3d 0.0;\n    #ifdef RECEIVE_SHADOWS\n      shadow \x3d evalShadow(vpos, linearDepth, depthTex, shadowMapNum, shadowMapDistance, shadowMapMatrix, depthHalfPixelSz);\n    #elif defined(VIEWING_MODE_GLOBAL)\n      // at global scale (and in global scenes) we fall back to this approximation\n      // to shadow objects on the dark side of the earth\n      shadow \x3d lightingGlobalFactor * (1.0 - additionalAmbientScale);\n    #endif\n\n\n]]\x3e\x3c/snippet\x3e\n\n\x3c!-- Keep is synchronized with the logic in Material.js:isVisible --\x3e\n\x3csnippet name\x3d"externalColorMix"\x3e\x3c![CDATA[\n  vec3 matColor \x3d max(ambient, diffuse); // combine the old material parameters into a single one\n  #if defined(VERTEXCOLORS)\n      // Internal colors: varying vcolor + uniform ambient/diffuse, external colors: varying vcolorExt\n      vec3 albedo_ \x3d mixExternalColor(vcolor.rgb * matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n      float opacity_ \x3d layerOpacity * mixExternalOpacity(vcolor.a * opacity, texColor.a, vcolorExt.a, int(colorMixMode));\n  #else\n      // Internal colors: uniform ambient/diffuse, external colors: varying vcolorExt\n      vec3 albedo_ \x3d mixExternalColor(matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n      float opacity_ \x3d layerOpacity * mixExternalOpacity(opacity, texColor.a, vcolorExt.a, int(colorMixMode));\n  #endif\n  albedo_+\x3d 0.25 * specular; // don\'t completely ignore specular for now\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"vsPhong"\x3e\x3c![CDATA[\n  $vsprecisionf\n\n  $vsPhongSrc\n  }\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"fsPhong"\x3e\x3c![CDATA[\n    $fsprecisionf\n\n    $fsPhongSrc\n\n    vec4 texColor \x3d vec4(1,1,1,1);\n    $externalColorMix\n\n    if (opacity_ \x3c 0.001) {\n      discard;\n    }\n\n    vec3 shadedColor \x3d evaluateSceneLighting(normal, albedo_, shadow, 1.0 - ssao, additionalLight);\n\n    gl_FragColor \x3d vec4(shadedColor, opacity_);\n  }\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"vsPhongTextured"\x3e\x3c![CDATA[\n  $vsprecisionf\n\n  attribute vec2 $uv0;\n  varying vec2 vtc;\n  $vsPhongSrc\n#ifndef FLIPV\n    vtc \x3d $uv0;\n#else\n    vtc \x3d vec2($uv0.x, 1.0-$uv0.y);\n#endif\n\n  }\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"fsPhongTextured"\x3e\x3c![CDATA[\n  $fsprecisionf\n\n  uniform sampler2D tex;\n  varying vec2 vtc;\n\n  $fsPhongSrc\n\n    // read texture color\n    vec4 texColor \x3d texture2D(tex, vtc);\n    if (texColor.a \x3c .33) discard;\n\n    $externalColorMix\n\n    if (opacity_ \x3c 0.001) {\n      discard;\n    }\n\n    vec3 shadedColor \x3d evaluateSceneLighting(normal, albedo_, shadow, 1.0 - ssao, additionalLight);\n\n    gl_FragColor \x3d vec4(shadedColor, opacity_);\n  }\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"vsPhongAtlasTextured"\x3e\x3c![CDATA[\n  $vsprecisionf\n\n  attribute vec4 $uv0;\n  attribute vec4 $region;\n  varying vec2 vtc;\n  varying vec4 regionV;\n  $vsPhongSrc\n#ifndef FLIPV\n    vtc \x3d $uv0.xy;\n#else\n    vtc \x3d vec2($uv0.x, 1.0-$uv0.y);\n#endif\n    regionV \x3d $region/65535.0;\n  }\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"fsPhongAtlasTextured"\x3e\x3c![CDATA[\n  $fsprecisionf\n\n  uniform sampler2D tex;\n  uniform vec2 texSize;\n  varying vec2 vtc;\n  varying vec4 regionV;\n\n  float calcMipMapLevel(const vec2 ddx, const vec2 ddy) {\n    // from:\n    //   - OpenGLES Common Profile Specification Version 2.0.25, Section 3.7.7 - Texture Minification\n    //   - https://www.opengl.org/discussion_boards/showthread.php/171485-Texture-LOD-calculation-(useful-for-atlasing)\n    //   - http://www.linedef.com/virtual-texture-demo.html\n    float deltaMaxSqr \x3d max(dot(ddx, ddx), dot(ddy, ddy));\n    return max(0.5 * log2(deltaMaxSqr), 0.0);\n  }\n\n  $fsPhongSrc\n\n    vec2 uv \x3d vtc;\n    uv \x3d fract(uv);\n    //[umin, vmin, umax, vmax]\n\n    vec2 atlasScale \x3d regionV.zw - regionV.xy;\n    uv \x3d uv.xy * atlasScale + regionV.xy;\n\n    vec4 texColor;\n    #ifdef GL_OES_standard_derivatives\n      #extension GL_OES_standard_derivatives : enable\n\n      // calculate derivative of continuous texture coordinate\n      // to avoid mipmapping artifacts caused by manual wrapping in shader\n      vec2 dUVdx \x3d dFdx(vtc) * atlasScale;\n      vec2 dUVdy \x3d dFdy(vtc) * atlasScale;\n\n      #ifdef GL_EXT_shader_texture_lod\n        #extension GL_EXT_shader_texture_lod : enable\n\n        // workaround for artifacts in Windows 10 using Intel HD Graphics 4000 series\n        // see: https://devtopia.esri.com/Zurich-R-D-Center/arcgis-js-api-canvas3d-issues/issues/768\n        const float epsilon \x3d 1.0E-32;\n        float zeroUVShift \x3d uv.x \x3d\x3d 0.0 \x26\x26 uv.y \x3d\x3d 0.0 ? epsilon : 0.0;\n\n        texColor \x3d texture2DGradEXT(tex, uv + zeroUVShift, dUVdx, dUVdy);\n      #else\n        // use bias to compensate for difference in automatic vs desired mipmap level\n        vec2 dUVdxAuto \x3d dFdx(uv);\n        vec2 dUVdyAuto \x3d dFdy(uv);\n        float mipMapLevel \x3d calcMipMapLevel(dUVdx * texSize, dUVdy * texSize);\n        float autoMipMapLevel \x3d calcMipMapLevel(dUVdxAuto * texSize, dUVdyAuto * texSize);\n        texColor \x3d texture2D(tex, uv, mipMapLevel - autoMipMapLevel);\n      #endif\n    #else\n      texColor \x3d texture2D(tex, uv);\n    #endif\n\n    if (texColor.a \x3c .33) discard;\n\n    $externalColorMix\n\n    if (opacity_ \x3c 0.001) {\n      discard;\n    }\n\n    vec3 shadedColor \x3d evaluateSceneLighting(normal, albedo_, shadow, 1.0 - ssao, additionalLight);\n    gl_FragColor \x3d vec4(shadedColor, opacity_);\n  }\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"vsDepthSrc"\x3e\x3c![CDATA[\n  uniform mat4 proj;\n  uniform mat4 view;\n  uniform vec3 camPos;\n  uniform vec3 localOrigin;\n\n#ifdef INSTANCED\n  attribute mat4 model;\n  attribute mat4 modelNormal;\n#else\n  uniform mat4 model;\n  uniform mat4 modelNormal;\n#endif\n  uniform vec2 nearFar;\n  attribute vec3 $position;\n  varying float depth;\n\n  $vvUniforms\n#if defined(VV_CUSTOM_MODEL_MATRIX)\n  attribute vec4 instanceFeatureAttribute;\n#endif\n  $vvFunctions\n\n  $calculateVerticalOffset\n\n  void main(void) {\n\n#ifdef VV_CUSTOM_MODEL_MATRIX\n\n    vec3 vpos \x3d (model * vvTransformPosition($position, instanceFeatureAttribute)).xyz;\n\n#ifdef VERTICAL_OFFSET\n    vec3 centerPos \x3d (model * vvTransformPosition(vec3(0, 0, 0), instanceFeatureAttribute)).xyz;\n#endif\n\n#else /* VV_CUSTOM_MODEL_MATRIX */\n\n    vec3 vpos \x3d (model * vec4($position, 1.0)).xyz;\n\n#ifdef VERTICAL_OFFSET\n    vec3 centerPos \x3d (model * vec4(vec3(0, 0, 0), 1.0)).xyz;\n#endif\n\n#endif /* VV_CUSTOM_MODEL_MATRIX */\n\n#ifdef VERTICAL_OFFSET\n    vpos +\x3d calculateVerticalOffset(centerPos, localOrigin);\n#endif\n\n    vec4 eye \x3d view * vec4(vpos, 1);\n\n    gl_Position \x3d proj * eye;\n    depth \x3d (-eye.z - nearFar[0]) / (nearFar[1] - nearFar[0]) ;\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"vsDepth"\x3e\x3c![CDATA[\n  $vsprecisionf\n\n  $vsDepthSrc\n  }\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"vsDepthTextured"\x3e\x3c![CDATA[\n  $vsprecisionf\n\n  attribute vec2 $uv0;\n  varying vec2 vtc;\n  $vsDepthSrc\n#ifndef FLIPV\n        vtc \x3d $uv0;\n#else\n        vtc \x3d vec2($uv0.x, 1.0-$uv0.y);\n#endif\n  }\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"vsNormalSrc"\x3e\x3c![CDATA[\n  uniform mat4 proj;\n  uniform mat4 view;\n  uniform vec3 camPos;\n  uniform vec3 localOrigin;\n\n#ifdef INSTANCED\n  attribute mat4 model;\n  attribute mat4 modelNormal;\n#else\n  uniform mat4 model;\n  uniform mat4 modelNormal;\n#endif\n  uniform mat4 viewNormal;\n  attribute vec3 $position;\n#ifdef COMPRESSED_NORMALS\n  attribute vec2 $normalCompressed;\n#else\n  attribute vec3 $normal;\n#endif\n  varying vec3 vnormal;\n\n  $vvUniforms\n#if defined(VV_CUSTOM_MODEL_MATRIX)\n  attribute vec4 instanceFeatureAttribute;\n#endif\n  $vvFunctions\n\n  $calculateVerticalOffset\n\n  $decodeNormal\n\n  void main(void) {\n\n#ifdef VV_CUSTOM_MODEL_MATRIX\n\n    vec3 vpos \x3d (model * vvTransformPosition($position, instanceFeatureAttribute)).xyz;\n#ifdef COMPRESSED_NORMALS\n    vnormal \x3d normalize((viewNormal * modelNormal * vvTransformNormal(decodeNormal($normalCompressed), instanceFeatureAttribute)).xyz);\n#else\n    vnormal \x3d normalize((viewNormal * modelNormal * vvTransformNormal($normal, instanceFeatureAttribute)).xyz);\n#endif\n\n#ifdef VERTICAL_OFFSET\n    vec3 centerPos \x3d (model * vvTransformPosition(vec3(0, 0, 0), instanceFeatureAttribute)).xyz;\n#endif\n\n#else /* VV_CUSTOM_MODEL_MATRIX */\n    vec3 vpos \x3d (model * vec4($position, 1.0)).xyz;\n#ifdef COMPRESSED_NORMALS\n    vnormal \x3d normalize((viewNormal * modelNormal * vec4(decodeNormal($normalCompressed), 1.0)).xyz);\n#else\n    vnormal \x3d normalize((viewNormal * modelNormal * vec4($normal, 1.0)).xyz);\n#endif\n\n#ifdef VERTICAL_OFFSET\n    vec3 centerPos \x3d (model * vec4(vec3(0, 0, 0), 1.0)).xyz;\n#endif\n\n#endif /* VV_CUSTOM_MODEL_MATRIX */\n\n#ifdef VERTICAL_OFFSET\n    vpos +\x3d calculateVerticalOffset(centerPos, localOrigin);\n#endif\n\n    gl_Position \x3d proj * view * vec4(vpos, 1);\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"vsNormal"\x3e\x3c![CDATA[\n  $vsprecisionf\n\n  $vsNormalSrc\n  }\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"vsNormalTextured"\x3e\x3c![CDATA[\n  $vsprecisionf\n\n  attribute vec2 $uv0;\n  varying vec2 vtc;\n  $vsNormalSrc\n#ifndef FLIPV\n    vtc \x3d $uv0;\n#else\n    vtc \x3d vec2($uv0.x, 1.0-$uv0.y);\n#endif\n  }\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"vsHighlightSrc"\x3e\x3c![CDATA[\n  $vsprecisionf\n\n  uniform mat4 proj;\n  uniform mat4 view;\n  uniform vec3 camPos;\n  uniform vec3 localOrigin;\n\n#ifdef INSTANCED\n  attribute mat4 model;\n  attribute mat4 modelNormal;\n#else\n  uniform mat4 model;\n  uniform mat4 modelNormal;\n#endif\n  attribute vec3 $position;\n\n  $vvUniforms\n#if defined(VV_CUSTOM_MODEL_MATRIX)\n  attribute vec4 instanceFeatureAttribute;\n#endif\n  $vvFunctions\n\n  $calculateVerticalOffset\n\n  void main(void) {\n\n#ifdef VV_CUSTOM_MODEL_MATRIX\n\n    vec3 vpos \x3d (model * vvTransformPosition($position, instanceFeatureAttribute)).xyz;\n\n#ifdef VERTICAL_OFFSET\n    vec3 centerPos \x3d (model * vvTransformPosition(vec3(0, 0, 0), instanceFeatureAttribute)).xyz;\n#endif\n\n#else /* VV_CUSTOM_MODEL_MATRIX */\n\n    vec3 vpos \x3d (model * vec4($position, 1.0)).xyz;\n\n#ifdef VERTICAL_OFFSET\n    vec3 centerPos \x3d (model * vec4(vec3(0, 0, 0), 1.0)).xyz;\n#endif\n\n#endif /* VV_CUSTOM_MODEL_MATRIX */\n\n#ifdef VERTICAL_OFFSET\n    vpos +\x3d calculateVerticalOffset(centerPos, localOrigin);\n#endif\n\n    gl_Position \x3d proj * view * vec4(vpos, 1);\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"vsHighlight"\x3e\x3c![CDATA[\n  $vsHighlightSrc\n  }\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"vsHighlightTextured"\x3e\x3c![CDATA[\n  $vsprecisionf\n\n  attribute vec2 $uv0;\n  varying vec2 vtc;\n  $vsHighlightSrc\n#ifndef FLIPV\n    vtc \x3d $uv0;\n#else\n    vtc \x3d vec2($uv0.x, 1.0-$uv0.y);\n#endif\n  }\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"fsDepthSrc"\x3e\x3c![CDATA[\n  $fsprecisionf\n  varying float depth;\n\n  void main() {\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"fsDepth"\x3e\x3c![CDATA[\n  $fsprecisionf\n\n  $calcFragDepth\n  $float2rgba\n  $fsDepthSrc\n#ifndef BIAS_SHADOWMAP\n    gl_FragColor \x3d float2rgba(depth);\n#else\n    gl_FragColor \x3d float2rgba(calcFragDepth(depth));\n#endif\n  }\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"fsDepthTextured"\x3e\x3c![CDATA[\n  $fsprecisionf\n\n  uniform sampler2D tex;\n  varying vec2 vtc;\n  $calcFragDepth\n  $float2rgba\n\n  $fsDepthSrc\n    if (texture2D(tex, vtc).a \x3c .33) discard;\n#ifndef BIAS_SHADOWMAP\n    gl_FragColor \x3d float2rgba(depth);\n#else\n    gl_FragColor \x3d float2rgba(calcFragDepth(depth));\n#endif\n  }\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"fsNormal"\x3e\x3c![CDATA[\n  $fsprecisionf\n\n  varying vec3 vnormal;\n  void main() {\n    vec3 normal \x3d normalize(vnormal);\n    if (gl_FrontFacing \x3d\x3d false) normal \x3d -normal;\n\n#ifndef ALPHA_ZERO\n    gl_FragColor \x3d vec4(vec3(.5) + .5 * normal, 1.0);\n#else\n    gl_FragColor \x3d vec4(vec3(.5) + .5 * normal, 0.0);\n#endif\n\n  }\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"fsNormalTextured"\x3e\x3c![CDATA[\n  $fsprecisionf\n\n  varying vec3 vnormal;\n  varying vec2 vtc;\n  uniform sampler2D tex;\n  void main() {\n    if (texture2D(tex, vtc).a \x3c .33) discard;\n    vec3 normal \x3d normalize(vnormal);\n    if (gl_FrontFacing \x3d\x3d false) normal \x3d -normal;\n#ifndef ALPHA_ZERO\n    gl_FragColor \x3d vec4(vec3(.5) + .5 * normal, 1.0);\n#else\n    gl_FragColor \x3d vec4(vec3(.5) + .5 * normal, 0.0);\n#endif\n  }\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"fsHighlight"\x3e\x3c![CDATA[\n  $fsprecisionf\n  uniform sampler2D depthTex;\n  uniform vec4 highlightViewportPixelSz;\n\n  void main() {\n    $highlightWrite\n  }\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"fsHighlightTextured"\x3e\x3c![CDATA[\n  $fsprecisionf\n\n  varying vec2 vtc;\n  uniform sampler2D tex;\n  uniform sampler2D depthTex;\n  uniform vec4 highlightViewportPixelSz;\n\n  void main() {\n    if (texture2D(tex, vtc).a \x3c .33) discard;\n\n    $highlightWrite\n  }\n]]\x3e\x3c/snippet\x3e\n\n\x3c/snippets\x3e\n'}});
define("require exports ../../../../core/tsSupport/extendsHelper dojo/text!./DefaultMaterial.xml ../../layers/graphics/graphicUtils ../../support/buffer/glUtil ../../support/buffer/InterleavedLayout ../lib/DefaultVertexAttributeLocations ../lib/gl-matrix ../lib/GLMaterialTexture ../lib/Material ../lib/RenderSlot ../lib/ShaderVariations ../lib/Util ./internal/MaterialUtil ../../../webgl/Program ../../../webgl/Util".split(" "),function(D,ga,m,S,T,E,F,k,q,r,U,z,t,V,h,n,u){function v(d,b){var a=d.gl;
(b.cullFace?"none"===b.cullFace:b.transparent)?d.setFaceCullingEnabled(!1):(d.setFaceCullingEnabled(!0),"front"===b.cullFace&&d.setCullFace(a.FRONT))}function w(d,b){var a=d.gl;(b.cullFace?"none"===b.cullFace:b.transparent)?d.setFaceCullingEnabled(!0):(d.setFaceCullingEnabled(!1),"front"===b.cullFace&&d.setCullFace(a.BACK))}function p(d,b){return d?z.TRANSPARENT_MATERIAL:b?z.STENCIL_MATERIAL:z.OPAQUE_MATERIAL}function x(d,b){var a=b.vvSizeEnabled;b.vvSizeEnabled?(d.setUniform3fv("vvSizeMinSize",b.vvSizeMinSize),
d.setUniform3fv("vvSizeMaxSize",b.vvSizeMaxSize),d.setUniform3fv("vvSizeOffset",b.vvSizeOffset),d.setUniform3fv("vvSizeFactor",b.vvSizeFactor)):a&&d.setUniform3fv("vvSizeValue",b.vvSizeValue);a&&(d.setUniform3fv("vvSymbolAnchor",b.vvSymbolAnchor),T.computeObjectRotation(b.vvSymbolRotation[2],b.vvSymbolRotation[0],b.vvSymbolRotation[1],A.identity(G)),d.setUniformMatrix3fv("vvSymbolRotation",A.toMat3(G,W)));b.vvColorEnabled&&(d.setUniform1fv("vvColorValues",b.vvColorValues),d.setUniform4fv("vvColorColors",
b.vvColorColors))}function y(d,b){d.vvSizeEnabled=b.vvSizeEnabled;d.vvSizeMinSize=b.vvSizeMinSize;d.vvSizeMaxSize=b.vvSizeMaxSize;d.vvSizeOffset=b.vvSizeOffset;d.vvSizeFactor=b.vvSizeFactor;d.vvSizeValue=b.vvSizeValue;d.vvSymbolAnchor=b.vvSymbolAnchor;d.vvSymbolRotation=b.vvSymbolRotation}var f=q.vec3d,H=q.vec4d,I=q.mat3d,A=q.mat4d,J=V.assert;D=function(d){function b(a,c){c=d.call(this,c)||this;c.supportsEdges=!0;c.params=h.copyParameters(a,X);c.instanced=!!a.instanced;c.vertexBufferLayout=b.getVertexBufferLayout(c.params);
c.instanceBufferLayout=c.instanced?b.getInstanceBufferLayout(c.params):null;return c}m(b,d);b.prototype.isVisible=function(){var a=this.params;if(!d.prototype.isVisible.call(this)||0===a.layerOpacity)return!1;var c=l&&a.instanced,e=a.vertexColors,g=a.symbolColors,c=!!c&&-1<c.indexOf("color"),b=a.vvColorEnabled,h="replace"===a.colorMixMode,f=0<a.opacity,a=a.externalColor&&0<a.externalColor[3];return e&&(c||b||g)?h?!0:f:e?h?a:f:c||b||g?h?!0:f:h?a:f};b.prototype.getParams=function(){return this.params};
b.prototype.getParameterValues=function(){var a=this.params;return{textureId:a.textureId,ambient:a.ambient,diffuse:a.diffuse,specular:a.specular,externalColor:a.externalColor,colorMixMode:a.colorMixMode,opacity:a.opacity,layerOpacity:a.layerOpacity,transparent:a.transparent,polygonOffset:a.polygonOffset,atlasRegions:a.atlasRegions,flipV:a.flipV,doubleSided:a.doubleSided,doubleSidedType:a.doubleSidedType,cullFace:a.cullFace,writeStencil:a.writeStencil,receiveSSAO:a.receiveSSAO,castShadows:a.castShadows,
verticalOffset:a.verticalOffset,screenSizePerspective:a.screenSizePerspective,vvSizeEnabled:a.vvSizeEnabled,vvSizeMinSize:a.vvSizeMinSize,vvSizeMaxSize:a.vvSizeMaxSize,vvSizeOffset:a.vvSizeOffset,vvSizeFactor:a.vvSizeFactor,vvSizeValue:a.vvSizeValue,vvColorEnabled:a.vvColorEnabled,vvColorValues:a.vvColorValues,vvColorColors:a.vvColorColors,compressedNormals:a.compressedNormals,groundNormalShading:a.groundNormalShading,vvSymbolAnchor:a.vvSymbolAnchor,vvSymbolRotation:a.vvSymbolRotation}};b.prototype.setParameterValues=
function(a){var c=this.params,e;for(e in a)"textureId"===e&&J(c.textureId,"Can only change texture of material that already has a texture"),"castShadows"===e&&J(a.castShadows===c.castShadows,"Can not change shadow casting behavior."),c[e]=a[e];this.notifyDirty("matChanged")};b.prototype.getOutputAmount=function(a){var c=u.getStride(this.vertexBufferLayout)/4;return a*c};b.prototype.getVertexBufferLayout=function(){return this.vertexBufferLayout};b.prototype.getInstanceBufferLayout=function(){return this.instanceBufferLayout};
b.prototype.fillInterleaved=function(a,c,e,b,d,f,k){h.fillInterleaved(a,c,e,b,this.vertexBufferLayout,d,f,k)};b.prototype.intersect=function(a,c,e,b,d,k,n,l){if(null!==this.params.verticalOffset){l=b.camera;f.set3(e[12],e[13],e[14],B);var g=f.subtract(B,l.eye,Y),K=f.length(g),m=f.scale(g,1/K),p=null,g=null;switch(b.viewingMode){case "global":g=f.normalize(B,L);break;case "local":g=f.set(Z,L)}this.params.screenSizePerspective&&(p=f.dot(g,m));l=h.verticalOffsetAtDistance(l,K,this.params.verticalOffset,
p,this.params.screenSizePerspective);f.scale(g,l);I.multiplyVec3(b.transformInverseRotation,g,C);d=f.subtract(d,C,aa);k=f.subtract(k,C,ba)}h.intersectTriangleGeometry(a,c,e,b,d,k,n)};b.prototype.getGLMaterials=function(){return{color:ca,depthShadowMap:this.params.castShadows?da:null,normal:ea,depth:M,highlight:fa}};b.prototype.getAllTextureIds=function(){var a=this.params,c=[];a.textureId&&c.push(a.textureId);return c};b.loadShaders=function(a,c,e){a._parse(S);l=null!==e.capabilities.instancing;var b=
new t("phong",["vsPhong","fsPhong"],null,c,a,e);b.addNaryShaderSnippetSuffix([{value:"none",programNameSuffix:"",shaderSnippetSuffix:""},{value:"Textured"},{value:"AtlasTextured"}]);b.addDefine("Color","VERTEXCOLORS");b.addDefine("symbolColor","SYMBOLVERTEXCOLORS");b.addDefine("FlipV","FLIPV");b.addDefine("DoubleSided","DOUBLESIDED");b.addDefine("WindingOrderDoubleSided","WINDINGORDERDOUBLESIDED");b.addDefine("Instanced","INSTANCED");b.addDefine("InstColor","INSTANCEDCOLOR");b.addDefine("ReceiveShadows",
"RECEIVE_SHADOWS");b.addDefine("ReceiveSSAO","RECEIVE_SSAO");b.addDefine("vvSize","VV_SIZE");b.addDefine("vvColor","VV_COLOR");b.addDefine("VerticalOffset","VERTICAL_OFFSET");b.addDefine("screenSizePerspective","SCREEN_SIZE_PERSPECTIVE");b.addDefine("groundNormalShading","GROUND_NORMAL_SHADING");b.addDefine("compressedNormals","COMPRESSED_NORMALS");b.addDefine("componentColor","COMPONENTCOLORS");c.addShaderVariations(N,b);b=new t("depth",["vsDepth","fsDepth"],null,c,a,e);b.addNaryShaderSnippetSuffix([{value:"none",
programNameSuffix:"",shaderSnippetSuffix:""},{value:"Textured"},{value:"AtlasTextured"}]);b.addDefine("FlipV","FLIPV");b.addDefine("Instanced","INSTANCED");b.addDefine("ShadowMap","BIAS_SHADOWMAP");b.addDefine("vvSize","VV_SIZE");b.addDefine("VerticalOffset","VERTICAL_OFFSET");b.addDefine("screenSizePerspective","SCREEN_SIZE_PERSPECTIVE");c.addShaderVariations(O,b);b=new t("normal",["vsNormal","fsNormal"],null,c,a,e);b.addNaryShaderSnippetSuffix([{value:"none",programNameSuffix:"",shaderSnippetSuffix:""},
{value:"Textured"},{value:"AtlasTextured"}]);b.addDefine("FlipV","FLIPV");b.addDefine("Instanced","INSTANCED");b.addDefine("vvSize","VV_SIZE");b.addDefine("VerticalOffset","VERTICAL_OFFSET");b.addDefine("screenSizePerspective","SCREEN_SIZE_PERSPECTIVE");b.addDefine("compressedNormals","COMPRESSED_NORMALS");c.addShaderVariations(P,b);b=new t("highlight",["vsHighlight","fsHighlight"],null,c,a,e);b.addNaryShaderSnippetSuffix([{value:"none",programNameSuffix:"",shaderSnippetSuffix:""},{value:"Textured"},
{value:"AtlasTextured"}]);b.addDefine("FlipV","FLIPV");b.addDefine("Instanced","INSTANCED");b.addDefine("vvSize","VV_SIZE");b.addDefine("VerticalOffset","VERTICAL_OFFSET");b.addDefine("screenSizePerspective","SCREEN_SIZE_PERSPECTIVE");c.addShaderVariations(Q,b);var b=new n(e,a.vsDepth,a.fsDepth,k.Default3D,["BIAS_SHADOWMAP 1"]),d=new n(e,a.vsDepthTextured,a.fsDepthTextured,k.Default3D,["BIAS_SHADOWMAP 1"]),h=new n(e,a.vsDepth,a.fsDepth,k.Default3D),f=new n(e,a.vsDepthTextured,a.fsDepthTextured,k.Default3D),
m=new n(e,a.vsNormal,a.fsNormal,k.Default3D),p=new n(e,a.vsNormalTextured,a.fsNormalTextured,k.Default3D),q=new n(e,a.vsHighlight,a.fsHighlight,k.Default3D);a=new n(e,a.vsHighlightTextured,a.fsHighlightTextured,k.Default3D);c.add("depthShadowMap",b);c.add("depthTexturedShadowMap",d);c.add("depth",h);c.add("depthTextured",f);c.add("normal",m);c.add("normalTextured",p);c.add("highlight",q);c.add("highlightTextured",a)};b.getVertexBufferLayout=function(a){var c=F.newLayout().vec3f("position");a.groundNormalShading||
(c=a.compressedNormals?c.vec2i16("normalCompressed",{glNormalized:!0}):c.vec3f("normal"));a.textureId&&(c=c.vec2f("uv0"),a.atlasRegions&&(c=c.vec4u16("region")));a.vertexColors&&(c=c.vec4u8("color"));a.symbolColors&&(c=c.vec4u8("symbolColor"));a.componentIndices&&(c=c.u16("componentIndex").u16("_padding",{glPadding:!0}));return E.glLayout(c)};b.getInstanceBufferLayout=function(a){var c=F.newLayout().mat4f("model").mat4f("modelNormal");a.instanced&&-1<a.instanced.indexOf("color")&&(c=c.vec4f("instanceColor"));
a.instanced&&-1<a.instanced.indexOf("featureAttribute")&&(c=c.vec4f("instanceFeatureAttribute"));return E.glLayout(c,{divisor:1})};return b}(U);var ca=function(d){function b(a,c,b){c=d.call(this,a,c,b,a.getParams().textureId)||this;c.programs=[[null,null],[null,null]];c.params=h.copyParameters(a.getParams());c.slot=p(c.params.transparent,c.params.writeStencil);a=c.params;c.texturing=a.textureId?a.atlasRegions?"AtlasTextured":"Textured":"none";b=l&&a.instanced;c.instanced=!!b;c.instancedColor=!!b&&
-1<b.indexOf("color");c.pseudoInstancedColor=!l&&a.instanced&&-1<a.instanced.indexOf("color");c._loadPrograms();return c}m(b,d);b.prototype._loadPrograms=function(){this.programs[0][0]=this._loadProgram(!1,!1);this.programs[1][0]=this._loadProgram(!0,!1);this.params.receiveSSAO?(this.programs[0][1]=this._loadProgram(!1,!0),this.programs[1][1]=this._loadProgram(!0,!0),this.allPrograms=this.programs[0].concat(this.programs[1])):(this.programs[0][1]=this.programs[0][0],this.programs[1][1]=this.programs[1][0],
this.allPrograms=[this.programs[0][0],this.programs[1][0]])};b.prototype._loadProgram=function(a,c){var b=this.params;return this.programRep.getShaderVariationsProgram(N,[this.texturing,b.vertexColors,b.symbolColors,b.flipV,b.doubleSided&&"normal"===b.doubleSidedType,b.doubleSided&&"winding-order"===b.doubleSidedType,!!this.instanced,this.instancedColor,a,c,b.vvSizeEnabled,b.vvColorEnabled,null!==b.verticalOffset,null!==b.screenSizePerspective,b.groundNormalShading,b.compressedNormals,null!=b.componentColorBuffer])};
b.prototype.beginSlot=function(a){return a===this.slot};b.prototype.getProgram=function(){return this.program||this.programs[0][0]};b.prototype.getPrograms=function(){return this.allPrograms};b.prototype.updateParameters=function(){var a=this.material.getParams(),c=this.params;c.ambient=a.ambient;c.diffuse=a.diffuse;c.specular=a.specular;c.externalColor=a.externalColor;c.colorMixMode=a.colorMixMode;c.opacity=a.opacity;c.layerOpacity=a.layerOpacity;c.polygonOffset=a.polygonOffset;c.flipV=a.flipV;c.doubleSided=
a.doubleSided;c.doubleSidedType=a.doubleSidedType;c.cullFace=a.cullFace;c.receiveSSAO=a.receiveSSAO;c.castShadows=a.castShadows;c.verticalOffset=a.verticalOffset;c.screenSizePerspective=a.screenSizePerspective;y(c,a);c.vvColorEnabled=a.vvColorEnabled;c.vvColorValues=a.vvColorValues;c.vvColorColors=a.vvColorColors;c.transparent!==a.transparent&&(this.slot=p(a.transparent,a.writeStencil),c.transparent=a.transparent);c.compressedNormals=a.compressedNormals;c.groundNormalShading=a.groundNormalShading;
this.updateTexture(a.textureId);a.atlasRegions&&(c.atlasRegions=a.atlasRegions);c.blendModeOneOne=a.blendModeOneOne;c.inverseWindingOrder=a.inverseWindingOrder;this._loadPrograms()};b.prototype.bind=function(a,c){var b=a.gl,g=this.params,d=this.program=this.programs[c.shadowMappingEnabled?1:0][c.ssaoEnabled?1:0];a.bindProgram(d);d.setUniform3fv("ambient",g.ambient);d.setUniform3fv("diffuse",g.diffuse);d.setUniform3fv("specular",g.specular);d.setUniform4fv("externalColor",g.externalColor);d.setUniform1i("colorMixMode",
h.colorMixModes[g.colorMixMode]);d.setUniform1f("opacity",g.opacity);d.setUniform1f("layerOpacity",g.layerOpacity);h.bindVerticalOffset(g.verticalOffset,c,d);h.bindScreenSizePerspective(g.screenSizePerspective,d);x(d,g);this.bindTexture(a,d);"AtlasTextured"===this.texturing&&this.bindTextureSize(a,d);a.setBlendFunctionSeparate(b.SRC_ALPHA,b.ONE_MINUS_SRC_ALPHA,b.ONE,b.ONE_MINUS_SRC_ALPHA);g.inverseWindingOrder&&a.setFrontFace(b.CW);g.transparent?(a.setBlendingEnabled(!0),g.blendModeOneOne?(a.setBlendFunction(b.ONE,
b.ONE),a.setDepthWriteEnabled(!1)):a.setBlendFunctionSeparate(b.SRC_ALPHA,b.ONE_MINUS_SRC_ALPHA,b.ONE,b.ONE_MINUS_SRC_ALPHA)):a.setBlendingEnabled(!1);g.polygonOffset&&(a.setPolygonOffsetFillEnabled(!0),a.setPolygonOffset(2,2));v(a,g);a.setDepthTestEnabled(!0);g.componentIndices&&g.componentColorBuffer&&(g.componentColorBuffer.updateTexture(),g.componentColorBuffer.bind(d,{texName:"uComponentColorTex",invDimName:"uComponentColorTexInvDim",unit:1}))};b.prototype.release=function(a,c){c=a.gl;a.setPolygonOffsetFillEnabled(!1);
w(a,this.params);a.setBlendingEnabled(!1);a.setBlendFunctionSeparate(c.SRC_ALPHA,c.ONE_MINUS_SRC_ALPHA,c.ONE,c.ONE_MINUS_SRC_ALPHA);a.setDepthWriteEnabled(!0);a.setFrontFace(c.CCW)};b.prototype.bindView=function(a,c){a=this.program=this.programs[c.shadowMappingEnabled?1:0][c.ssaoEnabled?1:0];var b=c.origin;h.bindView(b,c.view,a);h.bindCamPos(b,c.viewInvTransp,a);c.shadowMappingEnabled&&c.shadowMap.bindView(a,b)};b.prototype.bindInstance=function(a,c){a=this.program;a.setUniformMatrix4fv("model",c.transformation);
a.setUniformMatrix4fv("modelNormal",c.transformationNormal);c.instanceParameters&&this.pseudoInstancedColor&&(c=c.instanceParameters.color)&&(H.multiply(c,this.params.externalColor,R),a.setUniform4fv("externalColor",R))};b.prototype.getDrawMode=function(a){return a.gl.TRIANGLES};return b}(r),M=function(d){function b(a,c,b,g){void 0===g&&(g=!1);b=d.call(this,a,c,b,a.getParams().textureId)||this;b.params=h.copyParameters(a.getParams());b.instanced=l&&!!b.params.instanced;b.texturing=u.hasAttribute(a.getVertexBufferLayout(),
"uv0")?"Textured":"none";b.program=c.getShaderVariationsProgram(O,[b.texturing,b.params.flipV,b.instanced,g,b.params.vvSizeEnabled,null!==b.params.verticalOffset,null!==b.params.screenSizePerspective]);b.slot=p(b.params.transparent,b.params.writeStencil);return b}m(b,d);b.prototype.beginSlot=function(a){return a===this.slot};b.prototype.getProgram=function(){return this.program};b.prototype.updateParameters=function(){var a=this.material.getParams(),b=this.params;b.cullFace=a.cullFace;b.inverseWindingOrder=
a.inverseWindingOrder;b.flipV=a.flipV;y(b,a);this.updateTexture(a.textureId)};b.prototype.bind=function(a,b){var c=a.gl,d=this.program,f=this.params;a.bindProgram(d);d.setUniform2fv("nearFar",b.nearFar);f.inverseWindingOrder&&a.setFrontFace(c.CW);h.bindVerticalOffset(f.verticalOffset,b,d);h.bindScreenSizePerspective(f.screenSizePerspective,d);x(d,f);this.bindTexture(a,d);v(a,f);a.setDepthTestEnabled(!0)};b.prototype.release=function(a){var b=a.gl,e=this.params;w(a,e);e.inverseWindingOrder&&a.setFrontFace(b.CCW)};
b.prototype.bindView=function(a,b){a=this.program;var c=this.params;h.bindView(b.origin,b.view,a);c.screenSizePerspective&&h.bindCamPos(b.origin,b.viewInvTransp,a)};b.prototype.bindInstance=function(a,b){this.program.setUniformMatrix4fv("model",b.transformation)};b.prototype.getDrawMode=function(a){return a.gl.TRIANGLES};return b}(r),da=function(d){function b(a,b,e){return d.call(this,a,b,e,!0)||this}m(b,d);return b}(M),ea=function(d){function b(a,b,e,g){void 0===g&&(g=!1);e=d.call(this,a,b,e,a.getParams().textureId)||
this;e.params=h.copyParameters(a.getParams());e.instanced=l&&!!e.params.instanced;e.texturing=u.hasAttribute(a.getVertexBufferLayout(),"uv0")?"Textured":"none";e.program=b.getShaderVariationsProgram(P,[e.texturing,e.params.flipV,e.instanced,e.params.vvSizeEnabled,null!==e.params.verticalOffset,null!==e.params.screenSizePerspective,e.params.compressedNormals]);e.slot=p(e.params.transparent,e.params.writeStencil);return e}m(b,d);b.prototype.beginSlot=function(a){return a===this.slot};b.prototype.getProgram=
function(){return this.program};b.prototype.updateParameters=function(){var a=this.material.getParams(),b=this.params;b.cullFace=a.cullFace;b.inverseWindingOrder=a.inverseWindingOrder;b.flipV=a.flipV;y(b,a);this.updateTexture(a.textureId)};b.prototype.bind=function(a,b){var c=a.gl,d=this.program,f=this.params;a.bindProgram(d);this.bindTexture(a,d);d.setUniformMatrix4fv("viewNormal",b.viewInvTransp);h.bindVerticalOffset(f.verticalOffset,b,d);h.bindScreenSizePerspective(f.screenSizePerspective,d);x(d,
f);v(a,f);f.inverseWindingOrder&&a.setFrontFace(c.CW);a.setDepthTestEnabled(!0)};b.prototype.release=function(a){var b=a.gl,d=this.params;w(a,d);d.inverseWindingOrder&&a.setFrontFace(b.CCW)};b.prototype.bindView=function(a,b){a=this.program;var c=this.params;h.bindView(b.origin,b.view,a);c.screenSizePerspective&&h.bindCamPos(b.origin,b.viewInvTransp,a)};b.prototype.bindInstance=function(a,b){a=this.program;a.setUniformMatrix4fv("model",b.transformation);a.setUniformMatrix4fv("modelNormal",b.transformationNormal)};
b.prototype.getDrawMode=function(a){return a.gl.TRIANGLES};return b}(r),fa=function(d){function b(a,b,e,g){void 0===g&&(g=!1);e=d.call(this,a,b,e,a.getParams().textureId)||this;e.params=h.copyParameters(a.getParams());e.instanced=l&&!!e.params.instanced;e.texturing=u.hasAttribute(a.getVertexBufferLayout(),"uv0")?"Textured":"none";e.program=b.getShaderVariationsProgram(Q,[e.texturing,e.params.flipV,e.instanced,e.params.vvSizeEnabled,null!==e.params.verticalOffset,null!==e.params.screenSizePerspective]);
e.slot=p(e.params.transparent,e.params.writeStencil);return e}m(b,d);b.prototype.beginSlot=function(a){return a===this.slot};b.prototype.getProgram=function(){return this.program};b.prototype.updateParameters=function(){var a=this.material.getParams(),b=this.params;b.cullFace=a.cullFace;b.inverseWindingOrder=a.inverseWindingOrder;b.flipV=a.flipV;y(b,a);this.updateTexture(a.textureId)};b.prototype.bind=function(a,b){var c=a.gl,d=this.program,f=this.params;a.bindProgram(d);this.bindTexture(a,d);h.bindVerticalOffset(f.verticalOffset,
b,d);h.bindScreenSizePerspective(f.screenSizePerspective,d);x(d,f);v(a,f);f.inverseWindingOrder&&a.setFrontFace(c.CW);a.setDepthTestEnabled(!0)};b.prototype.release=function(a){var b=a.gl,d=this.params;w(a,d);d.inverseWindingOrder&&a.setFrontFace(b.CW)};b.prototype.bindView=function(a,b){a=this.program;var c=this.params;h.bindView(b.origin,b.view,a);c.screenSizePerspective&&h.bindCamPos(b.origin,b.viewInvTransp,a)};b.prototype.bindInstance=function(a,b){a=this.program;a.setUniformMatrix4fv("model",
b.transformation);a.setUniformMatrix4fv("modelNormal",b.transformationNormal)};b.prototype.getDrawMode=function(a){return a.gl.TRIANGLES};return b}(r),X={textureId:void 0,ambient:[.2,.2,.2],diffuse:[.8,.8,.8],specular:[0,0,0],externalColor:[1,1,1,1],colorMixMode:"multiply",opacity:1,layerOpacity:1,blendModeOneOne:!1,inverseWindingOrder:!1,vertexColors:!1,symbolColors:!1,componentIndices:!1,componentColorBuffer:null,flipV:!1,doubleSided:!1,doubleSidedType:"normal",cullFace:void 0,instanced:void 0,
compressedNormals:!1,groundNormalShading:!1,writeStencil:!1,receiveSSAO:!0,castShadows:!0,verticalOffset:null,screenSizePerspective:null,vvSizeEnabled:!1,vvSizeMinSize:[1,1,1],vvSizeMaxSize:[100,100,100],vvSizeOffset:[0,0,0],vvSizeFactor:[1,1,1],vvSizeValue:[1,1,1],vvColorEnabled:!1,vvColorValues:[0,0,0,0,0,0,0,0],vvColorColors:[1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],vvSymbolAnchor:[0,0,0],vvSymbolRotation:[0,0,0],transparent:!1,polygonOffset:!1,atlasRegions:!1},l,N="material",
O="material-depth",P="material-normal",Q="material-highlight",R=H.create(),W=I.create(),G=A.create(),aa=f.create(),ba=f.create(),Z=f.createFrom(0,0,1),L=f.create(),C=f.create(),B=f.create(),Y=f.create();return D});